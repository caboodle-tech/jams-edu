{"version":3,"file":"global.js","mappings":"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","sources":["webpack://__IGNORE_THIS_PLACEHOLDER_VARIABLE__/webpack/bootstrap","webpack://__IGNORE_THIS_PLACEHOLDER_VARIABLE__/webpack/runtime/define property getters","webpack://__IGNORE_THIS_PLACEHOLDER_VARIABLE__/webpack/runtime/hasOwnProperty shorthand","webpack://__IGNORE_THIS_PLACEHOLDER_VARIABLE__/webpack/runtime/make namespace object","webpack://__IGNORE_THIS_PLACEHOLDER_VARIABLE__/../custom-attributes/src/registry.ts","webpack://__IGNORE_THIS_PLACEHOLDER_VARIABLE__/../custom-attributes/src/index.ts","webpack://__IGNORE_THIS_PLACEHOLDER_VARIABLE__/./node_modules/solid-js/dist/solid.js","webpack://__IGNORE_THIS_PLACEHOLDER_VARIABLE__/./node_modules/solid-js/store/dist/store.js","webpack://__IGNORE_THIS_PLACEHOLDER_VARIABLE__/./src/index.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// TODO We don't know when a ShadowRoot is no longer referenced, hence we cannot\n// unobserve them. Verify that MOs are cleaned up once ShadowRoots are no longer\n// referenced.\n\nimport type {Constructor} from 'lowclass'\n\nconst forEach = Array.prototype.forEach\n\nexport interface CustomAttribute {\n\townerElement: Element\n\tname: string\n\tvalue: string\n\tconnectedCallback?(): void\n\tdisconnectedCallback?(): void\n\tchangedCallback?(oldValue: string, newValue: string): void\n}\n\nexport class CustomAttributeRegistry {\n\tprivate _attrMap = new Map<string, Constructor>()\n\tprivate _elementMap = new WeakMap<Element, Map<string, CustomAttribute>>()\n\n\tprivate _observer: MutationObserver = new MutationObserver(mutations => {\n\t\tforEach.call(mutations, (m: MutationRecord) => {\n\t\t\tif (m.type === 'attributes') {\n\t\t\t\tconst attr = this._getConstructor(m.attributeName!)\n\t\t\t\tif (attr) this._handleChange(m.attributeName!, m.target as Element, m.oldValue)\n\t\t\t}\n\t\t\t// chlidList\n\t\t\telse {\n\t\t\t\tforEach.call(m.removedNodes, this._elementDisconnected)\n\t\t\t\tforEach.call(m.addedNodes, this._elementConnected)\n\t\t\t}\n\t\t})\n\t})\n\n\tconstructor(public ownerDocument: Document | ShadowRoot) {\n\t\tif (!ownerDocument) throw new Error('Must be given a document')\n\t}\n\n\tdefine(attrName: string, Class: Constructor) {\n\t\tthis._attrMap.set(attrName, Class)\n\t\tthis._upgradeAttr(attrName)\n\t\tthis._reobserve()\n\t}\n\n\tget(element: Element, attrName: string) {\n\t\tconst map = this._elementMap.get(element)\n\t\tif (!map) return\n\t\treturn map.get(attrName)\n\t}\n\n\tprivate _getConstructor(attrName: string) {\n\t\treturn this._attrMap.get(attrName)\n\t}\n\n\tprivate _observe() {\n\t\tthis._observer.observe(this.ownerDocument, {\n\t\t\tchildList: true,\n\t\t\tsubtree: true,\n\t\t\tattributes: true,\n\t\t\tattributeOldValue: true,\n\t\t\tattributeFilter: [...this._attrMap.keys()],\n\t\t\t// attributeFilter: this._attrMap.keys(), // This works in Chrome, but TS complains, and not clear if it should work in all browsers yet: https://github.com/whatwg/dom/issues/1092\n\t\t})\n\t}\n\n\tprivate _unobserve() {\n\t\tthis._observer.disconnect()\n\t}\n\n\tprivate _reobserve() {\n\t\tthis._unobserve()\n\t\tthis._observe()\n\t}\n\n\tprivate _upgradeAttr(attrName: string, node: Element | Document | ShadowRoot = this.ownerDocument) {\n\t\tconst matches = node.querySelectorAll('[' + attrName + ']')\n\n\t\t// Possibly create custom attributes that may be in the given 'node' tree.\n\t\t// Use a forEach as Edge doesn't support for...of on a NodeList\n\t\tforEach.call(matches, (element: Element) => this._handleChange(attrName, element, null))\n\t}\n\n\tprivate _elementConnected = (element: Element) => {\n\t\tif (element.nodeType !== 1) return\n\n\t\t// For each of the connected element's attribute, possibly instantiate the custom attributes.\n\t\t// Use a forEach as Safari 10 doesn't support for...of on NamedNodeMap (attributes)\n\t\tforEach.call(element.attributes, (attr: Attr) => {\n\t\t\tif (this._getConstructor(attr.name)) this._handleChange(attr.name, element, null)\n\t\t})\n\n\t\t// Possibly instantiate custom attributes that may be in the subtree of the connected element.\n\t\tthis._attrMap.forEach((_constructor, attr) => this._upgradeAttr(attr, element))\n\t}\n\n\tprivate _elementDisconnected = (element: Element) => {\n\t\tconst map = this._elementMap.get(element)\n\t\tif (!map) return\n\n\t\tmap.forEach(inst => inst.disconnectedCallback?.(), this)\n\n\t\tthis._elementMap.delete(element)\n\t}\n\n\tprivate _handleChange(attrName: string, el: Element, oldVal: string | null) {\n\t\tlet map = this._elementMap.get(el)\n\t\tif (!map) this._elementMap.set(el, (map = new Map()))\n\n\t\tlet inst = map.get(attrName)\n\t\tconst newVal = el.getAttribute(attrName)\n\n\t\t// Attribute is being created\n\t\tif (!inst) {\n\t\t\tconst Constructor = this._getConstructor(attrName)!\n\t\t\tinst = new Constructor() as CustomAttribute\n\t\t\tmap.set(attrName, inst)\n\t\t\tinst.ownerElement = el\n\t\t\tinst.name = attrName\n\t\t\tif (newVal == null) throw new Error('Not possible!')\n\t\t\tinst.value = newVal\n\t\t\tinst.connectedCallback?.()\n\t\t\treturn\n\t\t}\n\n\t\t// Attribute was removed\n\t\tif (newVal == null) {\n\t\t\tinst.disconnectedCallback?.()\n\t\t\tmap.delete(attrName)\n\t\t}\n\n\t\t// Attribute changed\n\t\telse if (newVal !== inst.value) {\n\t\t\tinst.value = newVal\n\t\t\tif (oldVal == null) throw new Error('Not possible!')\n\t\t\tinst.changedCallback?.(oldVal, newVal)\n\t\t}\n\t}\n}\n\nexport default CustomAttributeRegistry\n","import {CustomAttributeRegistry} from './registry.js'\n\nconst win = window as any\nexport let customAttributes: CustomAttributeRegistry\n\nif (!win.$customAttributes?.skipPolyfill) {\n\tcustomAttributes = new CustomAttributeRegistry(document)\n\twin.customAttributes = customAttributes\n}\n\nexport * from './registry.js'\n\nexport const version = '0.1.3'\n","let taskIdCounter = 1,\n    isCallbackScheduled = false,\n    isPerformingWork = false,\n    taskQueue = [],\n    currentTask = null,\n    shouldYieldToHost = null,\n    yieldInterval = 5,\n    deadline = 0,\n    maxYieldInterval = 300,\n    scheduleCallback = null,\n    scheduledCallback = null;\nconst maxSigned31BitInt = 1073741823;\nfunction setupScheduler() {\n  const channel = new MessageChannel(),\n        port = channel.port2;\n  scheduleCallback = () => port.postMessage(null);\n  channel.port1.onmessage = () => {\n    if (scheduledCallback !== null) {\n      const currentTime = performance.now();\n      deadline = currentTime + yieldInterval;\n      const hasTimeRemaining = true;\n      try {\n        const hasMoreWork = scheduledCallback(hasTimeRemaining, currentTime);\n        if (!hasMoreWork) {\n          scheduledCallback = null;\n        } else port.postMessage(null);\n      } catch (error) {\n        port.postMessage(null);\n        throw error;\n      }\n    }\n  };\n  if (navigator && navigator.scheduling && navigator.scheduling.isInputPending) {\n    const scheduling = navigator.scheduling;\n    shouldYieldToHost = () => {\n      const currentTime = performance.now();\n      if (currentTime >= deadline) {\n        if (scheduling.isInputPending()) {\n          return true;\n        }\n        return currentTime >= maxYieldInterval;\n      } else {\n        return false;\n      }\n    };\n  } else {\n    shouldYieldToHost = () => performance.now() >= deadline;\n  }\n}\nfunction enqueue(taskQueue, task) {\n  function findIndex() {\n    let m = 0;\n    let n = taskQueue.length - 1;\n    while (m <= n) {\n      const k = n + m >> 1;\n      const cmp = task.expirationTime - taskQueue[k].expirationTime;\n      if (cmp > 0) m = k + 1;else if (cmp < 0) n = k - 1;else return k;\n    }\n    return m;\n  }\n  taskQueue.splice(findIndex(), 0, task);\n}\nfunction requestCallback(fn, options) {\n  if (!scheduleCallback) setupScheduler();\n  let startTime = performance.now(),\n      timeout = maxSigned31BitInt;\n  if (options && options.timeout) timeout = options.timeout;\n  const newTask = {\n    id: taskIdCounter++,\n    fn,\n    startTime,\n    expirationTime: startTime + timeout\n  };\n  enqueue(taskQueue, newTask);\n  if (!isCallbackScheduled && !isPerformingWork) {\n    isCallbackScheduled = true;\n    scheduledCallback = flushWork;\n    scheduleCallback();\n  }\n  return newTask;\n}\nfunction cancelCallback(task) {\n  task.fn = null;\n}\nfunction flushWork(hasTimeRemaining, initialTime) {\n  isCallbackScheduled = false;\n  isPerformingWork = true;\n  try {\n    return workLoop(hasTimeRemaining, initialTime);\n  } finally {\n    currentTask = null;\n    isPerformingWork = false;\n  }\n}\nfunction workLoop(hasTimeRemaining, initialTime) {\n  let currentTime = initialTime;\n  currentTask = taskQueue[0] || null;\n  while (currentTask !== null) {\n    if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || shouldYieldToHost())) {\n      break;\n    }\n    const callback = currentTask.fn;\n    if (callback !== null) {\n      currentTask.fn = null;\n      const didUserCallbackTimeout = currentTask.expirationTime <= currentTime;\n      callback(didUserCallbackTimeout);\n      currentTime = performance.now();\n      if (currentTask === taskQueue[0]) {\n        taskQueue.shift();\n      }\n    } else taskQueue.shift();\n    currentTask = taskQueue[0] || null;\n  }\n  return currentTask !== null;\n}\n\nconst sharedConfig = {};\nfunction setHydrateContext(context) {\n  sharedConfig.context = context;\n}\nfunction nextHydrateContext() {\n  return { ...sharedConfig.context,\n    id: `${sharedConfig.context.id}${sharedConfig.context.count++}-`,\n    count: 0\n  };\n}\n\nconst equalFn = (a, b) => a === b;\nconst $PROXY = Symbol(\"solid-proxy\");\nconst $TRACK = Symbol(\"solid-track\");\nconst $DEVCOMP = Symbol(\"solid-dev-component\");\nconst signalOptions = {\n  equals: equalFn\n};\nlet ERROR = null;\nlet runEffects = runQueue;\nconst NOTPENDING = {};\nconst STALE = 1;\nconst PENDING = 2;\nconst UNOWNED = {\n  owned: null,\n  cleanups: null,\n  context: null,\n  owner: null\n};\nconst [transPending, setTransPending] = /*@__PURE__*/createSignal(false);\nvar Owner = null;\nlet Transition = null;\nlet Scheduler = null;\nlet ExternalSourceFactory = null;\nlet Listener = null;\nlet Pending = null;\nlet Updates = null;\nlet Effects = null;\nlet ExecCount = 0;\nfunction createRoot(fn, detachedOwner) {\n  const listener = Listener,\n        owner = Owner,\n        unowned = fn.length === 0,\n        root = unowned && !false ? UNOWNED : {\n    owned: null,\n    cleanups: null,\n    context: null,\n    owner: detachedOwner || owner\n  },\n        updateFn = unowned ? fn : () => fn(() => cleanNode(root));\n  Owner = root;\n  Listener = null;\n  try {\n    return runUpdates(updateFn, true);\n  } finally {\n    Listener = listener;\n    Owner = owner;\n  }\n}\nfunction createSignal(value, options) {\n  options = options ? Object.assign({}, signalOptions, options) : signalOptions;\n  const s = {\n    value,\n    observers: null,\n    observerSlots: null,\n    pending: NOTPENDING,\n    comparator: options.equals || undefined\n  };\n  const setter = value => {\n    if (typeof value === \"function\") {\n      if (Transition && Transition.running && Transition.sources.has(s)) value = value(s.pending !== NOTPENDING ? s.pending : s.tValue);else value = value(s.pending !== NOTPENDING ? s.pending : s.value);\n    }\n    return writeSignal(s, value);\n  };\n  return [readSignal.bind(s), setter];\n}\nfunction createComputed(fn, value, options) {\n  const c = createComputation(fn, value, true, STALE);\n  if (Scheduler && Transition && Transition.running) Updates.push(c);else updateComputation(c);\n}\nfunction createRenderEffect(fn, value, options) {\n  const c = createComputation(fn, value, false, STALE);\n  if (Scheduler && Transition && Transition.running) Updates.push(c);else updateComputation(c);\n}\nfunction createEffect(fn, value, options) {\n  runEffects = runUserEffects;\n  const c = createComputation(fn, value, false, STALE),\n        s = SuspenseContext && lookup(Owner, SuspenseContext.id);\n  if (s) c.suspense = s;\n  c.user = true;\n  Effects ? Effects.push(c) : updateComputation(c);\n}\nfunction createReaction(onInvalidate, options) {\n  let fn;\n  const c = createComputation(() => {\n    fn ? fn() : untrack(onInvalidate);\n    fn = undefined;\n  }, undefined, false, 0),\n        s = SuspenseContext && lookup(Owner, SuspenseContext.id);\n  if (s) c.suspense = s;\n  c.user = true;\n  return tracking => {\n    fn = tracking;\n    updateComputation(c);\n  };\n}\nfunction createMemo(fn, value, options) {\n  options = options ? Object.assign({}, signalOptions, options) : signalOptions;\n  const c = createComputation(fn, value, true, 0);\n  c.pending = NOTPENDING;\n  c.observers = null;\n  c.observerSlots = null;\n  c.comparator = options.equals || undefined;\n  if (Scheduler && Transition && Transition.running) {\n    c.tState = STALE;\n    Updates.push(c);\n  } else updateComputation(c);\n  return readSignal.bind(c);\n}\nfunction createResource(source, fetcher, options) {\n  if (arguments.length === 2) {\n    if (typeof fetcher === \"object\") {\n      options = fetcher;\n      fetcher = source;\n      source = true;\n    }\n  } else if (arguments.length === 1) {\n    fetcher = source;\n    source = true;\n  }\n  options || (options = {});\n  const contexts = new Set(),\n        [value, setValue] = createSignal(options.initialValue),\n        [track, trigger] = createSignal(undefined, {\n    equals: false\n  }),\n        [loading, setLoading] = createSignal(false),\n        [error, setError] = createSignal();\n  let err = undefined,\n      pr = null,\n      initP = null,\n      id = null,\n      loadedUnderTransition = false,\n      scheduled = false,\n      resolved = (\"initialValue\" in options),\n      dynamic = typeof source === \"function\" && createMemo(source);\n  if (sharedConfig.context) {\n    id = `${sharedConfig.context.id}${sharedConfig.context.count++}`;\n    if (sharedConfig.load) initP = sharedConfig.load(id);\n  }\n  function loadEnd(p, v, e, key) {\n    if (pr === p) {\n      pr = null;\n      resolved = true;\n      if (initP && (p === initP || v === initP) && options.onHydrated) queueMicrotask(() => options.onHydrated(key, {\n        value: v\n      }));\n      initP = null;\n      setError(err = e);\n      if (Transition && p && loadedUnderTransition) {\n        Transition.promises.delete(p);\n        loadedUnderTransition = false;\n        runUpdates(() => {\n          Transition.running = true;\n          if (!Transition.promises.size) {\n            Effects.push.apply(Effects, Transition.effects);\n            Transition.effects = [];\n          }\n          completeLoad(v);\n        }, false);\n      } else completeLoad(v);\n    }\n    return v;\n  }\n  function completeLoad(v) {\n    batch(() => {\n      setValue(() => v);\n      setLoading(false);\n      for (const c of contexts.keys()) c.decrement();\n      contexts.clear();\n    });\n  }\n  function read() {\n    const c = SuspenseContext && lookup(Owner, SuspenseContext.id),\n          v = value();\n    if (err) throw err;\n    if (Listener && !Listener.user && c) {\n      createComputed(() => {\n        track();\n        if (pr) {\n          if (c.resolved && Transition) Transition.promises.add(pr);else if (!contexts.has(c)) {\n            c.increment();\n            contexts.add(c);\n          }\n        }\n      });\n    }\n    return v;\n  }\n  function load(refetching = true) {\n    if (refetching && scheduled) return;\n    scheduled = false;\n    setError(err = undefined);\n    const lookup = dynamic ? dynamic() : source;\n    loadedUnderTransition = Transition && Transition.running;\n    if (lookup == null || lookup === false) {\n      loadEnd(pr, untrack(value));\n      return;\n    }\n    if (Transition && pr) Transition.promises.delete(pr);\n    const p = initP || untrack(() => fetcher(lookup, {\n      value: value(),\n      refetching\n    }));\n    if (typeof p !== \"object\" || !(\"then\" in p)) {\n      loadEnd(pr, p);\n      return p;\n    }\n    pr = p;\n    scheduled = true;\n    queueMicrotask(() => scheduled = false);\n    batch(() => {\n      setLoading(true);\n      trigger();\n    });\n    return p.then(v => loadEnd(p, v, undefined, lookup), e => loadEnd(p, e, e));\n  }\n  Object.defineProperties(read, {\n    loading: {\n      get() {\n        return loading();\n      }\n    },\n    error: {\n      get() {\n        return error();\n      }\n    },\n    latest: {\n      get() {\n        if (!resolved) return read();\n        if (err) throw err;\n        return value();\n      }\n    }\n  });\n  if (dynamic) createComputed(() => load(false));else load(false);\n  return [read, {\n    refetch: load,\n    mutate: setValue\n  }];\n}\nfunction createDeferred(source, options) {\n  let t,\n      timeout = options ? options.timeoutMs : undefined;\n  const node = createComputation(() => {\n    if (!t || !t.fn) t = requestCallback(() => setDeferred(() => node.value), timeout !== undefined ? {\n      timeout\n    } : undefined);\n    return source();\n  }, undefined, true);\n  const [deferred, setDeferred] = createSignal(node.value, options);\n  updateComputation(node);\n  setDeferred(() => node.value);\n  return deferred;\n}\nfunction createSelector(source, fn = equalFn, options) {\n  const subs = new Map();\n  const node = createComputation(p => {\n    const v = source();\n    for (const key of subs.keys()) if (fn(key, v) !== fn(key, p)) {\n      const l = subs.get(key);\n      for (const c of l.values()) {\n        c.state = STALE;\n        if (c.pure) Updates.push(c);else Effects.push(c);\n      }\n    }\n    return v;\n  }, undefined, true, STALE);\n  updateComputation(node);\n  return key => {\n    let listener;\n    if (listener = Listener) {\n      let l;\n      if (l = subs.get(key)) l.add(listener);else subs.set(key, l = new Set([listener]));\n      onCleanup(() => {\n        l.delete(listener);\n        !l.size && subs.delete(key);\n      });\n    }\n    return fn(key, Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value);\n  };\n}\nfunction batch(fn) {\n  if (Pending) return fn();\n  let result;\n  const q = Pending = [];\n  try {\n    result = fn();\n  } finally {\n    Pending = null;\n  }\n  runUpdates(() => {\n    for (let i = 0; i < q.length; i += 1) {\n      const data = q[i];\n      if (data.pending !== NOTPENDING) {\n        const pending = data.pending;\n        data.pending = NOTPENDING;\n        writeSignal(data, pending);\n      }\n    }\n  }, false);\n  return result;\n}\nfunction untrack(fn) {\n  let result,\n      listener = Listener;\n  Listener = null;\n  result = fn();\n  Listener = listener;\n  return result;\n}\nfunction on(deps, fn, options) {\n  const isArray = Array.isArray(deps);\n  let prevInput;\n  let defer = options && options.defer;\n  return prevValue => {\n    let input;\n    if (isArray) {\n      input = Array(deps.length);\n      for (let i = 0; i < deps.length; i++) input[i] = deps[i]();\n    } else input = deps();\n    if (defer) {\n      defer = false;\n      return undefined;\n    }\n    const result = untrack(() => fn(input, prevInput, prevValue));\n    prevInput = input;\n    return result;\n  };\n}\nfunction onMount(fn) {\n  createEffect(() => untrack(fn));\n}\nfunction onCleanup(fn) {\n  if (Owner === null) ;else if (Owner.cleanups === null) Owner.cleanups = [fn];else Owner.cleanups.push(fn);\n  return fn;\n}\nfunction onError(fn) {\n  ERROR || (ERROR = Symbol(\"error\"));\n  if (Owner === null) ;else if (Owner.context === null) Owner.context = {\n    [ERROR]: [fn]\n  };else if (!Owner.context[ERROR]) Owner.context[ERROR] = [fn];else Owner.context[ERROR].push(fn);\n}\nfunction getListener() {\n  return Listener;\n}\nfunction getOwner() {\n  return Owner;\n}\nfunction runWithOwner(o, fn) {\n  const prev = Owner;\n  Owner = o;\n  try {\n    return runUpdates(fn, true);\n  } finally {\n    Owner = prev;\n  }\n}\nfunction enableScheduling(scheduler = requestCallback) {\n  Scheduler = scheduler;\n}\nfunction startTransition(fn) {\n  if (Transition && Transition.running) {\n    fn();\n    return Transition.done;\n  }\n  const l = Listener;\n  const o = Owner;\n  return Promise.resolve().then(() => {\n    Listener = l;\n    Owner = o;\n    let t;\n    if (Scheduler || SuspenseContext) {\n      t = Transition || (Transition = {\n        sources: new Set(),\n        effects: [],\n        promises: new Set(),\n        disposed: new Set(),\n        queue: new Set(),\n        running: true\n      });\n      t.done || (t.done = new Promise(res => t.resolve = res));\n      t.running = true;\n    }\n    batch(fn);\n    Listener = Owner = null;\n    return t ? t.done : undefined;\n  });\n}\nfunction useTransition() {\n  return [transPending, startTransition];\n}\nfunction resumeEffects(e) {\n  Effects.push.apply(Effects, e);\n  e.length = 0;\n}\nfunction createContext(defaultValue) {\n  const id = Symbol(\"context\");\n  return {\n    id,\n    Provider: createProvider(id),\n    defaultValue\n  };\n}\nfunction useContext(context) {\n  let ctx;\n  return (ctx = lookup(Owner, context.id)) !== undefined ? ctx : context.defaultValue;\n}\nfunction children(fn) {\n  const children = createMemo(fn);\n  return createMemo(() => resolveChildren(children()));\n}\nlet SuspenseContext;\nfunction getSuspenseContext() {\n  return SuspenseContext || (SuspenseContext = createContext({}));\n}\nfunction enableExternalSource(factory) {\n  if (ExternalSourceFactory) {\n    const oldFactory = ExternalSourceFactory;\n    ExternalSourceFactory = (fn, trigger) => {\n      const oldSource = oldFactory(fn, trigger);\n      const source = factory(x => oldSource.track(x), trigger);\n      return {\n        track: x => source.track(x),\n        dispose() {\n          source.dispose();\n          oldSource.dispose();\n        }\n      };\n    };\n  } else {\n    ExternalSourceFactory = factory;\n  }\n}\nfunction readSignal() {\n  const runningTransition = Transition && Transition.running;\n  if (this.sources && (!runningTransition && this.state || runningTransition && this.tState)) {\n    const updates = Updates;\n    Updates = null;\n    !runningTransition && this.state === STALE || runningTransition && this.tState === STALE ? updateComputation(this) : lookUpstream(this);\n    Updates = updates;\n  }\n  if (Listener) {\n    const sSlot = this.observers ? this.observers.length : 0;\n    if (!Listener.sources) {\n      Listener.sources = [this];\n      Listener.sourceSlots = [sSlot];\n    } else {\n      Listener.sources.push(this);\n      Listener.sourceSlots.push(sSlot);\n    }\n    if (!this.observers) {\n      this.observers = [Listener];\n      this.observerSlots = [Listener.sources.length - 1];\n    } else {\n      this.observers.push(Listener);\n      this.observerSlots.push(Listener.sources.length - 1);\n    }\n  }\n  if (runningTransition && Transition.sources.has(this)) return this.tValue;\n  return this.value;\n}\nfunction writeSignal(node, value, isComp) {\n  if (Pending) {\n    if (node.pending === NOTPENDING) Pending.push(node);\n    node.pending = value;\n    return value;\n  }\n  if (node.comparator) {\n    if (Transition && Transition.running && Transition.sources.has(node)) {\n      if (node.comparator(node.tValue, value)) return value;\n    } else if (node.comparator(node.value, value)) return value;\n  }\n  let TransitionRunning = false;\n  if (Transition) {\n    TransitionRunning = Transition.running;\n    if (TransitionRunning || !isComp && Transition.sources.has(node)) {\n      Transition.sources.add(node);\n      node.tValue = value;\n    }\n    if (!TransitionRunning) node.value = value;\n  } else node.value = value;\n  if (node.observers && node.observers.length) {\n    runUpdates(() => {\n      for (let i = 0; i < node.observers.length; i += 1) {\n        const o = node.observers[i];\n        if (TransitionRunning && Transition.disposed.has(o)) continue;\n        if (TransitionRunning && !o.tState || !TransitionRunning && !o.state) {\n          if (o.pure) Updates.push(o);else Effects.push(o);\n          if (o.observers) markDownstream(o);\n        }\n        if (TransitionRunning) o.tState = STALE;else o.state = STALE;\n      }\n      if (Updates.length > 10e5) {\n        Updates = [];\n        if (false) ;\n        throw new Error();\n      }\n    }, false);\n  }\n  return value;\n}\nfunction updateComputation(node) {\n  if (!node.fn) return;\n  cleanNode(node);\n  const owner = Owner,\n        listener = Listener,\n        time = ExecCount;\n  Listener = Owner = node;\n  runComputation(node, Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value, time);\n  if (Transition && !Transition.running && Transition.sources.has(node)) {\n    queueMicrotask(() => {\n      runUpdates(() => {\n        Transition && (Transition.running = true);\n        runComputation(node, node.tValue, time);\n      }, false);\n    });\n  }\n  Listener = listener;\n  Owner = owner;\n}\nfunction runComputation(node, value, time) {\n  let nextValue;\n  try {\n    nextValue = node.fn(value);\n  } catch (err) {\n    handleError(err);\n  }\n  if (!node.updatedAt || node.updatedAt <= time) {\n    if (node.observers && node.observers.length) {\n      writeSignal(node, nextValue, true);\n    } else if (Transition && Transition.running && node.pure) {\n      Transition.sources.add(node);\n      node.tValue = nextValue;\n    } else node.value = nextValue;\n    node.updatedAt = time;\n  }\n}\nfunction createComputation(fn, init, pure, state = STALE, options) {\n  const c = {\n    fn,\n    state: state,\n    updatedAt: null,\n    owned: null,\n    sources: null,\n    sourceSlots: null,\n    cleanups: null,\n    value: init,\n    owner: Owner,\n    context: null,\n    pure\n  };\n  if (Transition && Transition.running) {\n    c.state = 0;\n    c.tState = state;\n  }\n  if (Owner === null) ;else if (Owner !== UNOWNED) {\n    if (Transition && Transition.running && Owner.pure) {\n      if (!Owner.tOwned) Owner.tOwned = [c];else Owner.tOwned.push(c);\n    } else {\n      if (!Owner.owned) Owner.owned = [c];else Owner.owned.push(c);\n    }\n  }\n  if (ExternalSourceFactory) {\n    const [track, trigger] = createSignal(undefined, {\n      equals: false\n    });\n    const ordinary = ExternalSourceFactory(c.fn, trigger);\n    onCleanup(() => ordinary.dispose());\n    const triggerInTransition = () => startTransition(trigger).then(() => inTransition.dispose());\n    const inTransition = ExternalSourceFactory(c.fn, triggerInTransition);\n    c.fn = x => {\n      track();\n      return Transition && Transition.running ? inTransition.track(x) : ordinary.track(x);\n    };\n  }\n  return c;\n}\nfunction runTop(node) {\n  const runningTransition = Transition && Transition.running;\n  if (!runningTransition && node.state === 0 || runningTransition && node.tState === 0) return;\n  if (!runningTransition && node.state === PENDING || runningTransition && node.tState === PENDING) return lookUpstream(node);\n  if (node.suspense && untrack(node.suspense.inFallback)) return node.suspense.effects.push(node);\n  const ancestors = [node];\n  while ((node = node.owner) && (!node.updatedAt || node.updatedAt < ExecCount)) {\n    if (runningTransition && Transition.disposed.has(node)) return;\n    if (!runningTransition && node.state || runningTransition && node.tState) ancestors.push(node);\n  }\n  for (let i = ancestors.length - 1; i >= 0; i--) {\n    node = ancestors[i];\n    if (runningTransition) {\n      let top = node,\n          prev = ancestors[i + 1];\n      while ((top = top.owner) && top !== prev) {\n        if (Transition.disposed.has(top)) return;\n      }\n    }\n    if (!runningTransition && node.state === STALE || runningTransition && node.tState === STALE) {\n      updateComputation(node);\n    } else if (!runningTransition && node.state === PENDING || runningTransition && node.tState === PENDING) {\n      const updates = Updates;\n      Updates = null;\n      lookUpstream(node, ancestors[0]);\n      Updates = updates;\n    }\n  }\n}\nfunction runUpdates(fn, init) {\n  if (Updates) return fn();\n  let wait = false;\n  if (!init) Updates = [];\n  if (Effects) wait = true;else Effects = [];\n  ExecCount++;\n  try {\n    const res = fn();\n    completeUpdates(wait);\n    return res;\n  } catch (err) {\n    if (!Updates) Effects = null;\n    handleError(err);\n  }\n}\nfunction completeUpdates(wait) {\n  if (Updates) {\n    if (Scheduler && Transition && Transition.running) scheduleQueue(Updates);else runQueue(Updates);\n    Updates = null;\n  }\n  if (wait) return;\n  let res;\n  if (Transition && Transition.running) {\n    if (Transition.promises.size || Transition.queue.size) {\n      Transition.running = false;\n      Transition.effects.push.apply(Transition.effects, Effects);\n      Effects = null;\n      setTransPending(true);\n      return;\n    }\n    const sources = Transition.sources;\n    const disposed = Transition.disposed;\n    res = Transition.resolve;\n    for (const e of Effects) {\n      \"tState\" in e && (e.state = e.tState);\n      delete e.tState;\n    }\n    Transition = null;\n    batch(() => {\n      for (const d of disposed) cleanNode(d);\n      for (const v of sources) {\n        v.value = v.tValue;\n        if (v.owned) {\n          for (let i = 0, len = v.owned.length; i < len; i++) cleanNode(v.owned[i]);\n        }\n        if (v.tOwned) v.owned = v.tOwned;\n        delete v.tValue;\n        delete v.tOwned;\n        v.tState = 0;\n      }\n      setTransPending(false);\n    });\n  }\n  if (Effects.length) batch(() => {\n    runEffects(Effects);\n    Effects = null;\n  });else {\n    Effects = null;\n  }\n  if (res) res();\n}\nfunction runQueue(queue) {\n  for (let i = 0; i < queue.length; i++) runTop(queue[i]);\n}\nfunction scheduleQueue(queue) {\n  for (let i = 0; i < queue.length; i++) {\n    const item = queue[i];\n    const tasks = Transition.queue;\n    if (!tasks.has(item)) {\n      tasks.add(item);\n      Scheduler(() => {\n        tasks.delete(item);\n        runUpdates(() => {\n          Transition.running = true;\n          runTop(item);\n          if (!tasks.size) {\n            Effects.push.apply(Effects, Transition.effects);\n            Transition.effects = [];\n          }\n        }, false);\n        Transition && (Transition.running = false);\n      });\n    }\n  }\n}\nfunction runUserEffects(queue) {\n  let i,\n      userLength = 0;\n  for (i = 0; i < queue.length; i++) {\n    const e = queue[i];\n    if (!e.user) runTop(e);else queue[userLength++] = e;\n  }\n  if (sharedConfig.context) setHydrateContext();\n  const resume = queue.length;\n  for (i = 0; i < userLength; i++) runTop(queue[i]);\n  for (i = resume; i < queue.length; i++) runTop(queue[i]);\n}\nfunction lookUpstream(node, ignore) {\n  const runningTransition = Transition && Transition.running;\n  if (runningTransition) node.tState = 0;else node.state = 0;\n  for (let i = 0; i < node.sources.length; i += 1) {\n    const source = node.sources[i];\n    if (source.sources) {\n      if (!runningTransition && source.state === STALE || runningTransition && source.tState === STALE) {\n        if (source !== ignore) runTop(source);\n      } else if (!runningTransition && source.state === PENDING || runningTransition && source.tState === PENDING) lookUpstream(source, ignore);\n    }\n  }\n}\nfunction markDownstream(node) {\n  const runningTransition = Transition && Transition.running;\n  for (let i = 0; i < node.observers.length; i += 1) {\n    const o = node.observers[i];\n    if (!runningTransition && !o.state || runningTransition && !o.tState) {\n      if (runningTransition) o.tState = PENDING;else o.state = PENDING;\n      if (o.pure) Updates.push(o);else Effects.push(o);\n      o.observers && markDownstream(o);\n    }\n  }\n}\nfunction cleanNode(node) {\n  let i;\n  if (node.sources) {\n    while (node.sources.length) {\n      const source = node.sources.pop(),\n            index = node.sourceSlots.pop(),\n            obs = source.observers;\n      if (obs && obs.length) {\n        const n = obs.pop(),\n              s = source.observerSlots.pop();\n        if (index < obs.length) {\n          n.sourceSlots[s] = index;\n          obs[index] = n;\n          source.observerSlots[index] = s;\n        }\n      }\n    }\n  }\n  if (Transition && Transition.running && node.pure) {\n    if (node.tOwned) {\n      for (i = 0; i < node.tOwned.length; i++) cleanNode(node.tOwned[i]);\n      delete node.tOwned;\n    }\n    reset(node, true);\n  } else if (node.owned) {\n    for (i = 0; i < node.owned.length; i++) cleanNode(node.owned[i]);\n    node.owned = null;\n  }\n  if (node.cleanups) {\n    for (i = 0; i < node.cleanups.length; i++) node.cleanups[i]();\n    node.cleanups = null;\n  }\n  if (Transition && Transition.running) node.tState = 0;else node.state = 0;\n  node.context = null;\n}\nfunction reset(node, top) {\n  if (!top) {\n    node.tState = 0;\n    Transition.disposed.add(node);\n  }\n  if (node.owned) {\n    for (let i = 0; i < node.owned.length; i++) reset(node.owned[i]);\n  }\n}\nfunction handleError(err) {\n  const fns = ERROR && lookup(Owner, ERROR);\n  if (!fns) throw err;\n  for (const f of fns) f(err);\n}\nfunction lookup(owner, key) {\n  return owner ? owner.context && owner.context[key] !== undefined ? owner.context[key] : lookup(owner.owner, key) : undefined;\n}\nfunction resolveChildren(children) {\n  if (typeof children === \"function\" && !children.length) return resolveChildren(children());\n  if (Array.isArray(children)) {\n    const results = [];\n    for (let i = 0; i < children.length; i++) {\n      const result = resolveChildren(children[i]);\n      Array.isArray(result) ? results.push.apply(results, result) : results.push(result);\n    }\n    return results;\n  }\n  return children;\n}\nfunction createProvider(id) {\n  return function provider(props) {\n    let res;\n    createComputed(() => res = untrack(() => {\n      Owner.context = {\n        [id]: props.value\n      };\n      return children(() => props.children);\n    }));\n    return res;\n  };\n}\n\nfunction observable(input) {\n  return {\n    subscribe(observer) {\n      if (!(observer instanceof Object) || observer == null) {\n        throw new TypeError(\"Expected the observer to be an object.\");\n      }\n      const handler = typeof observer === 'function' ? observer : observer.next && observer.next.bind(observer);\n      if (!handler) {\n        return {\n          unsubscribe() {}\n        };\n      }\n      const dispose = createRoot(disposer => {\n        createComputed(() => {\n          const v = input();\n          untrack(() => handler(v));\n        });\n        return disposer;\n      });\n      if (getOwner()) onCleanup(dispose);\n      return {\n        unsubscribe() {\n          dispose();\n        }\n      };\n    },\n    [Symbol.observable || \"@@observable\"]() {\n      return this;\n    }\n  };\n}\nfunction from(producer) {\n  const [s, set] = createSignal(undefined, {\n    equals: false\n  });\n  if (\"subscribe\" in producer) {\n    const unsub = producer.subscribe(v => set(() => v));\n    onCleanup(() => \"unsubscribe\" in unsub ? unsub.unsubscribe() : unsub());\n  } else {\n    const clean = producer(set);\n    onCleanup(clean);\n  }\n  return s;\n}\n\nconst FALLBACK = Symbol(\"fallback\");\nfunction dispose(d) {\n  for (let i = 0; i < d.length; i++) d[i]();\n}\nfunction mapArray(list, mapFn, options = {}) {\n  let items = [],\n      mapped = [],\n      disposers = [],\n      len = 0,\n      indexes = mapFn.length > 1 ? [] : null;\n  onCleanup(() => dispose(disposers));\n  return () => {\n    let newItems = list() || [],\n        i,\n        j;\n    newItems[$TRACK];\n    return untrack(() => {\n      let newLen = newItems.length,\n          newIndices,\n          newIndicesNext,\n          temp,\n          tempdisposers,\n          tempIndexes,\n          start,\n          end,\n          newEnd,\n          item;\n      if (newLen === 0) {\n        if (len !== 0) {\n          dispose(disposers);\n          disposers = [];\n          items = [];\n          mapped = [];\n          len = 0;\n          indexes && (indexes = []);\n        }\n        if (options.fallback) {\n          items = [FALLBACK];\n          mapped[0] = createRoot(disposer => {\n            disposers[0] = disposer;\n            return options.fallback();\n          });\n          len = 1;\n        }\n      }\n      else if (len === 0) {\n        mapped = new Array(newLen);\n        for (j = 0; j < newLen; j++) {\n          items[j] = newItems[j];\n          mapped[j] = createRoot(mapper);\n        }\n        len = newLen;\n      } else {\n        temp = new Array(newLen);\n        tempdisposers = new Array(newLen);\n        indexes && (tempIndexes = new Array(newLen));\n        for (start = 0, end = Math.min(len, newLen); start < end && items[start] === newItems[start]; start++);\n        for (end = len - 1, newEnd = newLen - 1; end >= start && newEnd >= start && items[end] === newItems[newEnd]; end--, newEnd--) {\n          temp[newEnd] = mapped[end];\n          tempdisposers[newEnd] = disposers[end];\n          indexes && (tempIndexes[newEnd] = indexes[end]);\n        }\n        newIndices = new Map();\n        newIndicesNext = new Array(newEnd + 1);\n        for (j = newEnd; j >= start; j--) {\n          item = newItems[j];\n          i = newIndices.get(item);\n          newIndicesNext[j] = i === undefined ? -1 : i;\n          newIndices.set(item, j);\n        }\n        for (i = start; i <= end; i++) {\n          item = items[i];\n          j = newIndices.get(item);\n          if (j !== undefined && j !== -1) {\n            temp[j] = mapped[i];\n            tempdisposers[j] = disposers[i];\n            indexes && (tempIndexes[j] = indexes[i]);\n            j = newIndicesNext[j];\n            newIndices.set(item, j);\n          } else disposers[i]();\n        }\n        for (j = start; j < newLen; j++) {\n          if (j in temp) {\n            mapped[j] = temp[j];\n            disposers[j] = tempdisposers[j];\n            if (indexes) {\n              indexes[j] = tempIndexes[j];\n              indexes[j](j);\n            }\n          } else mapped[j] = createRoot(mapper);\n        }\n        mapped = mapped.slice(0, len = newLen);\n        items = newItems.slice(0);\n      }\n      return mapped;\n    });\n    function mapper(disposer) {\n      disposers[j] = disposer;\n      if (indexes) {\n        const [s, set] = createSignal(j);\n        indexes[j] = set;\n        return mapFn(newItems[j], s);\n      }\n      return mapFn(newItems[j]);\n    }\n  };\n}\nfunction indexArray(list, mapFn, options = {}) {\n  let items = [],\n      mapped = [],\n      disposers = [],\n      signals = [],\n      len = 0,\n      i;\n  onCleanup(() => dispose(disposers));\n  return () => {\n    const newItems = list() || [];\n    newItems[$TRACK];\n    return untrack(() => {\n      if (newItems.length === 0) {\n        if (len !== 0) {\n          dispose(disposers);\n          disposers = [];\n          items = [];\n          mapped = [];\n          len = 0;\n          signals = [];\n        }\n        if (options.fallback) {\n          items = [FALLBACK];\n          mapped[0] = createRoot(disposer => {\n            disposers[0] = disposer;\n            return options.fallback();\n          });\n          len = 1;\n        }\n        return mapped;\n      }\n      if (items[0] === FALLBACK) {\n        disposers[0]();\n        disposers = [];\n        items = [];\n        mapped = [];\n        len = 0;\n      }\n      for (i = 0; i < newItems.length; i++) {\n        if (i < items.length && items[i] !== newItems[i]) {\n          signals[i](() => newItems[i]);\n        } else if (i >= items.length) {\n          mapped[i] = createRoot(mapper);\n        }\n      }\n      for (; i < items.length; i++) {\n        disposers[i]();\n      }\n      len = signals.length = disposers.length = newItems.length;\n      items = newItems.slice(0);\n      return mapped = mapped.slice(0, len);\n    });\n    function mapper(disposer) {\n      disposers[i] = disposer;\n      const [s, set] = createSignal(newItems[i]);\n      signals[i] = set;\n      return mapFn(s, i);\n    }\n  };\n}\n\nlet hydrationEnabled = false;\nfunction enableHydration() {\n  hydrationEnabled = true;\n}\nfunction createComponent(Comp, props) {\n  if (hydrationEnabled) {\n    if (sharedConfig.context) {\n      const c = sharedConfig.context;\n      setHydrateContext(nextHydrateContext());\n      const r = untrack(() => Comp(props || {}));\n      setHydrateContext(c);\n      return r;\n    }\n  }\n  return untrack(() => Comp(props || {}));\n}\nfunction trueFn() {\n  return true;\n}\nconst propTraps = {\n  get(_, property, receiver) {\n    if (property === $PROXY) return receiver;\n    return _.get(property);\n  },\n  has(_, property) {\n    return _.has(property);\n  },\n  set: trueFn,\n  deleteProperty: trueFn,\n  getOwnPropertyDescriptor(_, property) {\n    return {\n      configurable: true,\n      enumerable: true,\n      get() {\n        return _.get(property);\n      },\n      set: trueFn,\n      deleteProperty: trueFn\n    };\n  },\n  ownKeys(_) {\n    return _.keys();\n  }\n};\nfunction resolveSource(s) {\n  return (s = typeof s === \"function\" ? s() : s) == null ? {} : s;\n}\nfunction mergeProps(...sources) {\n  return new Proxy({\n    get(property) {\n      for (let i = sources.length - 1; i >= 0; i--) {\n        const v = resolveSource(sources[i])[property];\n        if (v !== undefined) return v;\n      }\n    },\n    has(property) {\n      for (let i = sources.length - 1; i >= 0; i--) {\n        if (property in resolveSource(sources[i])) return true;\n      }\n      return false;\n    },\n    keys() {\n      const keys = [];\n      for (let i = 0; i < sources.length; i++) keys.push(...Object.keys(resolveSource(sources[i])));\n      return [...new Set(keys)];\n    }\n  }, propTraps);\n}\nfunction splitProps(props, ...keys) {\n  const blocked = new Set(keys.flat());\n  const descriptors = Object.getOwnPropertyDescriptors(props);\n  const res = keys.map(k => {\n    const clone = {};\n    for (let i = 0; i < k.length; i++) {\n      const key = k[i];\n      Object.defineProperty(clone, key, descriptors[key] ? descriptors[key] : {\n        get() {\n          return props[key];\n        },\n        set() {\n          return true;\n        }\n      });\n    }\n    return clone;\n  });\n  res.push(new Proxy({\n    get(property) {\n      return blocked.has(property) ? undefined : props[property];\n    },\n    has(property) {\n      return blocked.has(property) ? false : property in props;\n    },\n    keys() {\n      return Object.keys(props).filter(k => !blocked.has(k));\n    }\n  }, propTraps));\n  return res;\n}\nfunction lazy(fn) {\n  let comp;\n  let p;\n  const wrap = props => {\n    const ctx = sharedConfig.context;\n    if (ctx) {\n      const [s, set] = createSignal();\n      (p || (p = fn())).then(mod => {\n        setHydrateContext(ctx);\n        set(() => mod.default);\n        setHydrateContext();\n      });\n      comp = s;\n    } else if (!comp) {\n      const [s] = createResource(() => (p || (p = fn())).then(mod => mod.default));\n      comp = s;\n    } else {\n      const c = comp();\n      if (c) return c(props);\n    }\n    let Comp;\n    return createMemo(() => (Comp = comp()) && untrack(() => {\n      if (!ctx) return Comp(props);\n      const c = sharedConfig.context;\n      setHydrateContext(ctx);\n      const r = Comp(props);\n      setHydrateContext(c);\n      return r;\n    }));\n  };\n  wrap.preload = () => p || ((p = fn()).then(mod => comp = () => mod.default), p);\n  return wrap;\n}\nlet counter = 0;\nfunction createUniqueId() {\n  const ctx = sharedConfig.context;\n  return ctx ? `${ctx.id}${ctx.count++}` : `cl-${counter++}`;\n}\n\nfunction For(props) {\n  const fallback = \"fallback\" in props && {\n    fallback: () => props.fallback\n  };\n  return createMemo(mapArray(() => props.each, props.children, fallback ? fallback : undefined));\n}\nfunction Index(props) {\n  const fallback = \"fallback\" in props && {\n    fallback: () => props.fallback\n  };\n  return createMemo(indexArray(() => props.each, props.children, fallback ? fallback : undefined));\n}\nfunction Show(props) {\n  let strictEqual = false;\n  const condition = createMemo(() => props.when, undefined, {\n    equals: (a, b) => strictEqual ? a === b : !a === !b\n  });\n  return createMemo(() => {\n    const c = condition();\n    if (c) {\n      const child = props.children;\n      return (strictEqual = typeof child === \"function\" && child.length > 0) ? untrack(() => child(c)) : child;\n    }\n    return props.fallback;\n  });\n}\nfunction Switch(props) {\n  let strictEqual = false;\n  const conditions = children(() => props.children),\n        evalConditions = createMemo(() => {\n    let conds = conditions();\n    if (!Array.isArray(conds)) conds = [conds];\n    for (let i = 0; i < conds.length; i++) {\n      const c = conds[i].when;\n      if (c) return [i, c, conds[i]];\n    }\n    return [-1];\n  }, undefined, {\n    equals: (a, b) => a[0] === b[0] && (strictEqual ? a[1] === b[1] : !a[1] === !b[1]) && a[2] === b[2]\n  });\n  return createMemo(() => {\n    const [index, when, cond] = evalConditions();\n    if (index < 0) return props.fallback;\n    const c = cond.children;\n    return (strictEqual = typeof c === \"function\" && c.length > 0) ? untrack(() => c(when)) : c;\n  });\n}\nfunction Match(props) {\n  return props;\n}\nlet Errors;\nconst NoErrors = {};\nfunction resetErrorBoundaries() {\n  Errors && [...Errors].forEach(fn => fn(NoErrors));\n}\nfunction ErrorBoundary(props) {\n  let err = NoErrors;\n  if (sharedConfig.context && sharedConfig.load) {\n    err = sharedConfig.load(sharedConfig.context.id + sharedConfig.context.count) || NoErrors;\n  }\n  const [errored, setErrored] = createSignal(err);\n  Errors || (Errors = new Set());\n  Errors.add(setErrored);\n  onCleanup(() => Errors.delete(setErrored));\n  return createMemo(() => {\n    let e;\n    if ((e = errored()) !== NoErrors) {\n      const f = props.fallback;\n      return typeof f === \"function\" && f.length ? untrack(() => f(e, () => setErrored(NoErrors))) : f;\n    }\n    onError(setErrored);\n    return props.children;\n  });\n}\n\nconst SuspenseListContext = createContext();\nfunction SuspenseList(props) {\n  let suspenseSetter, showContent, showFallback;\n  const listContext = useContext(SuspenseListContext);\n  if (listContext) {\n    const [inFallback, setFallback] = createSignal(false);\n    suspenseSetter = setFallback;\n    [showContent, showFallback] = listContext.register(inFallback);\n  }\n  const [registry, setRegistry] = createSignal([]),\n        comp = createComponent(SuspenseListContext.Provider, {\n    value: {\n      register: inFallback => {\n        const [showingContent, showContent] = createSignal(false),\n              [showingFallback, showFallback] = createSignal(false);\n        setRegistry(registry => [...registry, {\n          inFallback,\n          showContent,\n          showFallback\n        }]);\n        return [showingContent, showingFallback];\n      }\n    },\n    get children() {\n      return props.children;\n    }\n  });\n  createComputed(() => {\n    const reveal = props.revealOrder,\n          tail = props.tail,\n          visibleContent = showContent ? showContent() : true,\n          visibleFallback = showFallback ? showFallback() : true,\n          reg = registry(),\n          reverse = reveal === \"backwards\";\n    if (reveal === \"together\") {\n      const all = reg.every(i => !i.inFallback());\n      suspenseSetter && suspenseSetter(!all);\n      reg.forEach(i => {\n        i.showContent(all && visibleContent);\n        i.showFallback(visibleFallback);\n      });\n      return;\n    }\n    let stop = false;\n    for (let i = 0, len = reg.length; i < len; i++) {\n      const n = reverse ? len - i - 1 : i,\n            s = reg[n].inFallback();\n      if (!stop && !s) {\n        reg[n].showContent(visibleContent);\n        reg[n].showFallback(visibleFallback);\n      } else {\n        const next = !stop;\n        if (next && suspenseSetter) suspenseSetter(true);\n        if (!tail || next && tail === \"collapsed\") {\n          reg[n].showFallback(visibleFallback);\n        } else reg[n].showFallback(false);\n        stop = true;\n        reg[n].showContent(next);\n      }\n    }\n    if (!stop && suspenseSetter) suspenseSetter(false);\n  });\n  return comp;\n}\nfunction Suspense(props) {\n  let counter = 0,\n      showContent,\n      showFallback,\n      ctx,\n      p,\n      flicker,\n      error;\n  const [inFallback, setFallback] = createSignal(false),\n        SuspenseContext = getSuspenseContext(),\n        store = {\n    increment: () => {\n      if (++counter === 1) setFallback(true);\n    },\n    decrement: () => {\n      if (--counter === 0) setFallback(false);\n    },\n    inFallback,\n    effects: [],\n    resolved: false\n  },\n        owner = getOwner();\n  if (sharedConfig.context && sharedConfig.load) {\n    const key = sharedConfig.context.id + sharedConfig.context.count;\n    p = sharedConfig.load(key);\n    if (p) {\n      if (typeof p !== \"object\" || !(\"then\" in p)) p = Promise.resolve(p);\n      const [s, set] = createSignal(undefined, {\n        equals: false\n      });\n      flicker = s;\n      p.then(err => {\n        if ((error = err) || sharedConfig.done) return set();\n        sharedConfig.gather(key);\n        setHydrateContext(ctx);\n        set();\n        setHydrateContext();\n      });\n    } else if (p === null) sharedConfig.gather(key);\n  }\n  const listContext = useContext(SuspenseListContext);\n  if (listContext) [showContent, showFallback] = listContext.register(store.inFallback);\n  let dispose;\n  onCleanup(() => dispose && dispose());\n  return createComponent(SuspenseContext.Provider, {\n    value: store,\n    get children() {\n      return createMemo(() => {\n        if (error) throw error;\n        ctx = sharedConfig.context;\n        if (flicker) {\n          flicker();\n          return flicker = undefined;\n        }\n        if (ctx && p === undefined) setHydrateContext();\n        const rendered = createMemo(() => props.children);\n        return createMemo(() => {\n          const inFallback = store.inFallback(),\n                visibleContent = showContent ? showContent() : true,\n                visibleFallback = showFallback ? showFallback() : true;\n          dispose && dispose();\n          if ((!inFallback || p !== undefined) && visibleContent) {\n            store.resolved = true;\n            ctx = p = undefined;\n            resumeEffects(store.effects);\n            return rendered();\n          }\n          if (!visibleFallback) return;\n          return createRoot(disposer => {\n            dispose = disposer;\n            if (ctx) {\n              setHydrateContext({\n                id: ctx.id + \"f\",\n                count: 0\n              });\n              ctx = undefined;\n            }\n            return props.fallback;\n          }, owner);\n        });\n      });\n    }\n  });\n}\n\nlet DEV;\n\nexport { $DEVCOMP, $PROXY, $TRACK, DEV, ErrorBoundary, For, Index, Match, Show, Suspense, SuspenseList, Switch, batch, cancelCallback, children, createComponent, createComputed, createContext, createDeferred, createEffect, createMemo, createReaction, createRenderEffect, createResource, createRoot, createSelector, createSignal, createUniqueId, enableExternalSource, enableHydration, enableScheduling, equalFn, from, getListener, getOwner, indexArray, lazy, mapArray, mergeProps, observable, on, onCleanup, onError, onMount, requestCallback, resetErrorBoundaries, runWithOwner, sharedConfig, splitProps, startTransition, untrack, useContext, useTransition };\n","import { $PROXY, $TRACK, getListener, batch, createSignal } from 'solid-js';\n\nconst $RAW = Symbol(\"store-raw\"),\n      $NODE = Symbol(\"store-node\"),\n      $NAME = Symbol(\"store-name\");\nfunction wrap$1(value, name) {\n  let p = value[$PROXY];\n  if (!p) {\n    Object.defineProperty(value, $PROXY, {\n      value: p = new Proxy(value, proxyTraps$1)\n    });\n    const keys = Object.keys(value),\n          desc = Object.getOwnPropertyDescriptors(value);\n    for (let i = 0, l = keys.length; i < l; i++) {\n      const prop = keys[i];\n      if (desc[prop].get) {\n        const get = desc[prop].get.bind(p);\n        Object.defineProperty(value, prop, {\n          get\n        });\n      }\n    }\n  }\n  return p;\n}\nfunction isWrappable(obj) {\n  let proto;\n  return obj != null && typeof obj === \"object\" && (obj[$PROXY] || !(proto = Object.getPrototypeOf(obj)) || proto === Object.prototype || Array.isArray(obj));\n}\nfunction unwrap(item, set = new Set()) {\n  let result, unwrapped, v, prop;\n  if (result = item != null && item[$RAW]) return result;\n  if (!isWrappable(item) || set.has(item)) return item;\n  if (Array.isArray(item)) {\n    if (Object.isFrozen(item)) item = item.slice(0);else set.add(item);\n    for (let i = 0, l = item.length; i < l; i++) {\n      v = item[i];\n      if ((unwrapped = unwrap(v, set)) !== v) item[i] = unwrapped;\n    }\n  } else {\n    if (Object.isFrozen(item)) item = Object.assign({}, item);else set.add(item);\n    const keys = Object.keys(item),\n          desc = Object.getOwnPropertyDescriptors(item);\n    for (let i = 0, l = keys.length; i < l; i++) {\n      prop = keys[i];\n      if (desc[prop].get) continue;\n      v = item[prop];\n      if ((unwrapped = unwrap(v, set)) !== v) item[prop] = unwrapped;\n    }\n  }\n  return item;\n}\nfunction getDataNodes(target) {\n  let nodes = target[$NODE];\n  if (!nodes) Object.defineProperty(target, $NODE, {\n    value: nodes = {}\n  });\n  return nodes;\n}\nfunction getDataNode(nodes, property, value) {\n  return nodes[property] || (nodes[property] = createDataNode(value, true));\n}\nfunction proxyDescriptor(target, property) {\n  const desc = Reflect.getOwnPropertyDescriptor(target, property);\n  if (!desc || desc.get || !desc.configurable || property === $PROXY || property === $NODE || property === $NAME) return desc;\n  delete desc.value;\n  delete desc.writable;\n  desc.get = () => target[$PROXY][property];\n  return desc;\n}\nfunction trackSelf(target) {\n  if (getListener()) {\n    const nodes = getDataNodes(target);\n    (nodes._ || (nodes._ = createDataNode()))();\n  }\n}\nfunction ownKeys(target) {\n  trackSelf(target);\n  return Reflect.ownKeys(target);\n}\nfunction createDataNode(value, equals) {\n  const [s, set] = createSignal(value, equals ? {\n    internal: true\n  } : {\n    equals: false,\n    internal: true\n  });\n  s.$ = set;\n  return s;\n}\nconst proxyTraps$1 = {\n  get(target, property, receiver) {\n    if (property === $RAW) return target;\n    if (property === $PROXY) return receiver;\n    if (property === $TRACK) return trackSelf(target);\n    const nodes = getDataNodes(target);\n    const tracked = nodes[property];\n    let value = tracked ? nodes[property]() : target[property];\n    if (property === $NODE || property === \"__proto__\") return value;\n    if (!tracked) {\n      const desc = Object.getOwnPropertyDescriptor(target, property);\n      if (getListener() && (typeof value !== \"function\" || target.hasOwnProperty(property)) && !(desc && desc.get)) value = getDataNode(nodes, property, value)();\n    }\n    return isWrappable(value) ? wrap$1(value) : value;\n  },\n  set() {\n    return true;\n  },\n  deleteProperty() {\n    return true;\n  },\n  ownKeys: ownKeys,\n  getOwnPropertyDescriptor: proxyDescriptor\n};\nfunction setProperty(state, property, value) {\n  if (state[property] === value) return;\n  const prev = state[property];\n  const len = state.length;\n  if (value === undefined) {\n    delete state[property];\n  } else state[property] = value;\n  let nodes = getDataNodes(state),\n      node;\n  if (node = getDataNode(nodes, property, prev)) node.$(() => value);\n  if (Array.isArray(state) && state.length !== len) (node = getDataNode(nodes, \"length\", len)) && node.$(state.length);\n  (node = nodes._) && node.$();\n}\nfunction mergeStoreNode(state, value) {\n  const keys = Object.keys(value);\n  for (let i = 0; i < keys.length; i += 1) {\n    const key = keys[i];\n    setProperty(state, key, value[key]);\n  }\n}\nfunction updateArray(current, next) {\n  if (typeof next === \"function\") next = next(current);\n  next = unwrap(next);\n  if (Array.isArray(next)) {\n    if (current === next) return;\n    let i = 0,\n        len = next.length;\n    for (; i < len; i++) {\n      const value = next[i];\n      if (current[i] !== value) setProperty(current, i, value);\n    }\n    setProperty(current, \"length\", len);\n  } else mergeStoreNode(current, next);\n}\nfunction updatePath(current, path, traversed = []) {\n  let part,\n      prev = current;\n  if (path.length > 1) {\n    part = path.shift();\n    const partType = typeof part,\n          isArray = Array.isArray(current);\n    if (Array.isArray(part)) {\n      for (let i = 0; i < part.length; i++) {\n        updatePath(current, [part[i]].concat(path), traversed);\n      }\n      return;\n    } else if (isArray && partType === \"function\") {\n      for (let i = 0; i < current.length; i++) {\n        if (part(current[i], i)) updatePath(current, [i].concat(path), traversed);\n      }\n      return;\n    } else if (isArray && partType === \"object\") {\n      const {\n        from = 0,\n        to = current.length - 1,\n        by = 1\n      } = part;\n      for (let i = from; i <= to; i += by) {\n        updatePath(current, [i].concat(path), traversed);\n      }\n      return;\n    } else if (path.length > 1) {\n      updatePath(current[part], path, [part].concat(traversed));\n      return;\n    }\n    prev = current[part];\n    traversed = [part].concat(traversed);\n  }\n  let value = path[0];\n  if (typeof value === \"function\") {\n    value = value(prev, traversed);\n    if (value === prev) return;\n  }\n  if (part === undefined && value == undefined) return;\n  value = unwrap(value);\n  if (part === undefined || isWrappable(prev) && isWrappable(value) && !Array.isArray(value)) {\n    mergeStoreNode(prev, value);\n  } else setProperty(current, part, value);\n}\nfunction createStore(...[store, options]) {\n  const unwrappedStore = unwrap(store || {});\n  const isArray = Array.isArray(unwrappedStore);\n  const wrappedStore = wrap$1(unwrappedStore);\n  function setStore(...args) {\n    batch(() => {\n      isArray && args.length === 1 ? updateArray(unwrappedStore, args[0]) : updatePath(unwrappedStore, args);\n    });\n  }\n  return [wrappedStore, setStore];\n}\n\nconst proxyTraps = {\n  get(target, property, receiver) {\n    if (property === $RAW) return target;\n    if (property === $PROXY) return receiver;\n    if (property === $TRACK) return trackSelf(target);\n    const nodes = getDataNodes(target);\n    const tracked = nodes[property];\n    let value = tracked ? nodes[property]() : target[property];\n    if (property === $NODE || property === \"__proto__\") return value;\n    if (!tracked) {\n      const desc = Object.getOwnPropertyDescriptor(target, property);\n      const isFunction = typeof value === \"function\";\n      if (getListener() && (!isFunction || target.hasOwnProperty(property)) && !(desc && desc.get)) value = getDataNode(nodes, property, value)();else if (value != null && isFunction && value === Array.prototype[property]) {\n        return (...args) => batch(() => Array.prototype[property].apply(receiver, args));\n      }\n    }\n    return isWrappable(value) ? wrap(value) : value;\n  },\n  set(target, property, value) {\n    batch(() => setProperty(target, property, unwrap(value)));\n    return true;\n  },\n  deleteProperty(target, property) {\n    batch(() => setProperty(target, property, undefined));\n    return true;\n  },\n  ownKeys: ownKeys,\n  getOwnPropertyDescriptor: proxyDescriptor\n};\nfunction wrap(value, name) {\n  let p = value[$PROXY];\n  if (!p) {\n    Object.defineProperty(value, $PROXY, {\n      value: p = new Proxy(value, proxyTraps)\n    });\n    const keys = Object.keys(value),\n          desc = Object.getOwnPropertyDescriptors(value);\n    for (let i = 0, l = keys.length; i < l; i++) {\n      const prop = keys[i];\n      if (desc[prop].get) {\n        const get = desc[prop].get.bind(p);\n        Object.defineProperty(value, prop, {\n          get\n        });\n      }\n      if (desc[prop].set) {\n        const og = desc[prop].set,\n              set = v => batch(() => og.call(p, v));\n        Object.defineProperty(value, prop, {\n          set\n        });\n      }\n    }\n  }\n  return p;\n}\nfunction createMutable(state, options) {\n  const unwrappedStore = unwrap(state || {});\n  const wrappedStore = wrap(unwrappedStore);\n  return wrappedStore;\n}\nfunction modifyMutable(state, modifier) {\n  batch(() => modifier(unwrap(state)));\n}\n\nconst $ROOT = Symbol(\"store-root\");\nfunction applyState(target, parent, property, merge, key) {\n  const previous = parent[property];\n  if (target === previous) return;\n  if (!isWrappable(target) || !isWrappable(previous) || key && target[key] !== previous[key]) {\n    if (target !== previous) {\n      if (property === $ROOT) return target;\n      setProperty(parent, property, target);\n    }\n    return;\n  }\n  if (Array.isArray(target)) {\n    if (target.length && previous.length && (!merge || key && target[0][key] != null)) {\n      let i, j, start, end, newEnd, item, newIndicesNext, keyVal;\n      for (start = 0, end = Math.min(previous.length, target.length); start < end && (previous[start] === target[start] || key && previous[start][key] === target[start][key]); start++) {\n        applyState(target[start], previous, start, merge, key);\n      }\n      const temp = new Array(target.length),\n            newIndices = new Map();\n      for (end = previous.length - 1, newEnd = target.length - 1; end >= start && newEnd >= start && (previous[end] === target[newEnd] || key && previous[end][key] === target[newEnd][key]); end--, newEnd--) {\n        temp[newEnd] = previous[end];\n      }\n      if (start > newEnd || start > end) {\n        for (j = start; j <= newEnd; j++) setProperty(previous, j, target[j]);\n        for (; j < target.length; j++) {\n          setProperty(previous, j, temp[j]);\n          applyState(target[j], previous, j, merge, key);\n        }\n        if (previous.length > target.length) setProperty(previous, \"length\", target.length);\n        return;\n      }\n      newIndicesNext = new Array(newEnd + 1);\n      for (j = newEnd; j >= start; j--) {\n        item = target[j];\n        keyVal = key ? item[key] : item;\n        i = newIndices.get(keyVal);\n        newIndicesNext[j] = i === undefined ? -1 : i;\n        newIndices.set(keyVal, j);\n      }\n      for (i = start; i <= end; i++) {\n        item = previous[i];\n        keyVal = key ? item[key] : item;\n        j = newIndices.get(keyVal);\n        if (j !== undefined && j !== -1) {\n          temp[j] = previous[i];\n          j = newIndicesNext[j];\n          newIndices.set(keyVal, j);\n        }\n      }\n      for (j = start; j < target.length; j++) {\n        if (j in temp) {\n          setProperty(previous, j, temp[j]);\n          applyState(target[j], previous, j, merge, key);\n        } else setProperty(previous, j, target[j]);\n      }\n    } else {\n      for (let i = 0, len = target.length; i < len; i++) {\n        applyState(target[i], previous, i, merge, key);\n      }\n    }\n    if (previous.length > target.length) setProperty(previous, \"length\", target.length);\n    return;\n  }\n  const targetKeys = Object.keys(target);\n  for (let i = 0, len = targetKeys.length; i < len; i++) {\n    applyState(target[targetKeys[i]], previous, targetKeys[i], merge, key);\n  }\n  const previousKeys = Object.keys(previous);\n  for (let i = 0, len = previousKeys.length; i < len; i++) {\n    if (target[previousKeys[i]] === undefined) setProperty(previous, previousKeys[i], undefined);\n  }\n}\nfunction reconcile(value, options = {}) {\n  const {\n    merge,\n    key = \"id\"\n  } = options,\n        v = unwrap(value);\n  return state => {\n    if (!isWrappable(state) || !isWrappable(v)) return v;\n    const res = applyState(v, {\n      [$ROOT]: state\n    }, $ROOT, merge, key);\n    return res === undefined ? state : res;\n  };\n}\nconst producers = new WeakMap();\nconst setterTraps = {\n  get(target, property) {\n    if (property === $RAW) return target;\n    const value = target[property];\n    let proxy;\n    return isWrappable(value) ? producers.get(value) || (producers.set(value, proxy = new Proxy(value, setterTraps)), proxy) : value;\n  },\n  set(target, property, value) {\n    setProperty(target, property, unwrap(value));\n    return true;\n  },\n  deleteProperty(target, property) {\n    setProperty(target, property, undefined);\n    return true;\n  }\n};\nfunction produce(fn) {\n  return state => {\n    if (isWrappable(state)) {\n      let proxy;\n      if (!(proxy = producers.get(state))) {\n        producers.set(state, proxy = new Proxy(state, setterTraps));\n      }\n      fn(proxy);\n    }\n    return state;\n  };\n}\n\nexport { $RAW, createMutable, createStore, modifyMutable, produce, reconcile, unwrap };\n","import {customAttributes, CustomAttributeRegistry, CustomAttribute} from '@lume/custom-attributes/dist/index.js'\nimport {$TRACK} from 'solid-js'\nimport {createMutable, modifyMutable, reconcile} from 'solid-js/store'\n\nimport type {Constructor} from 'lowclass'\n\n// TODO: element behaviors currently don't work on elements when they are\n// defined (via elementBehaviors.define()) after the elements are already in the\n// DOM. Make it order-independent.\n\ntype PossibleBehaviorInstance = {\n\tconnectedCallback?: (element: Element) => void\n\tdisconnectedCallback?: (element: Element) => void\n\tattributeChangedCallback?: (attr: string, oldValue: string | null, newValue: string | null, element: Element) => void\n\t[k: string]: any\n\t[k: number]: any\n}\n\ntype PossibleBehaviorConstructor = Constructor<\n\tPossibleBehaviorInstance,\n\t[ElementWithBehaviors],\n\t{awaitElementDefined?: boolean; observedAttributes?: string[]}\n>\n\nconst whenDefinedPromises: Map<string, Promise<void>> = new Map()\n\nclass BehaviorRegistry {\n\tprotected _definedBehaviors = new Map<string, PossibleBehaviorConstructor>()\n\n\tdefine<T extends PossibleBehaviorConstructor>(name: string, Behavior: T) {\n\t\tif (!this._definedBehaviors.has(name)) {\n\t\t\tthis._definedBehaviors.set(name, Behavior)\n\t\t} else {\n\t\t\tthrow new Error(`Behavior ${name} is already defined.`)\n\t\t}\n\t}\n\n\tget(name: string) {\n\t\treturn this._definedBehaviors.get(name)\n\t}\n\n\thas(name: string) {\n\t\treturn this._definedBehaviors.has(name)\n\t}\n\n\t// TODO WIP, similar to customElements.whenDefined, so that code can wait for\n\t// behaviors to be defined, which will help with load order issues when we\n\t// set autoDefineElements to true by default in LUME (causes elements to be\n\t// defined in module load order, which may not happen after all behaviors\n\t// are loaded).\n\twhenDefined(name: string) {\n\t\tlet resolve!: () => void\n\t\tconst p = new Promise<void>(r => (resolve = r))\n\n\t\tif (!this.has(name)) {\n\t\t\twhenDefinedPromises.set(name, p)\n\t\t} else {\n\t\t\tresolve()\n\t\t}\n\n\t\treturn p\n\t}\n}\n\ndeclare global {\n\tconst elementBehaviors: BehaviorRegistry\n\tinterface Window {\n\t\telementBehaviors: BehaviorRegistry\n\t}\n}\n\nexport const elementBehaviors = (window.elementBehaviors = new BehaviorRegistry())\n\n/**\n * A map of behavior names to their defined classes.\n *\n * Reactive in Solid.js.\n */\nexport class BehaviorMap extends Map<string, PossibleBehaviorInstance> {\n\t#reactivityTriggerObject = createMutable<Record<string, PossibleBehaviorInstance>>({})\n\n\tfind(predicate: (name: string, behavior: PossibleBehaviorInstance) => boolean) {\n\t\tlet result: PossibleBehaviorInstance | undefined = void undefined\n\n\t\tfor (const [name, behavior] of this) {\n\t\t\tif (!predicate(name, behavior)) continue\n\t\t\tresult = behavior\n\t\t\tbreak\n\t\t}\n\n\t\treturn result\n\t}\n\n\toverride get(key: string): PossibleBehaviorInstance | undefined {\n\t\t// read, causes tracking in Solid.js effects.\n\t\tthis.#reactivityTriggerObject[key]\n\n\t\treturn super.get(key)\n\t}\n\n\toverride set(key: string, value: PossibleBehaviorInstance): this {\n\t\tqueueMicrotask(() => {\n\t\t\t// write, triggers Solid.js effects\n\t\t\tthis.#reactivityTriggerObject[key] = value\n\t\t})\n\n\t\tsuper.set(key, value)\n\t\treturn this\n\t}\n\n\toverride delete(key: string): boolean {\n\t\tqueueMicrotask(() => {\n\t\t\t// write, triggers Solid.js effects\n\t\t\tdelete this.#reactivityTriggerObject[key]\n\t\t})\n\n\t\treturn super.delete(key)\n\t}\n\n\toverride clear(): void {\n\t\tqueueMicrotask(() => {\n\t\t\t// delete all properties, trigger single Solid.js effect update\n\t\t\tmodifyMutable(this.#reactivityTriggerObject, reconcile({}))\n\t\t})\n\n\t\tsuper.clear()\n\t}\n\n\toverride has(key: string): boolean {\n\t\t// read, causes tracking in Solid.js effects.\n\t\t// (TODO `in` operator not reactive yet, https://github.com/solidjs/solid/issues/1107)\n\t\t// key in this.#reactivityTriggerObject\n\t\t// Workaround, read the property\n\t\tthis.#reactivityTriggerObject[key]\n\n\t\treturn super.has(key)\n\t}\n\n\toverride entries(): IterableIterator<[string, PossibleBehaviorInstance]> {\n\t\t// track all properties in a Solid effect\n\t\t// @ts-expect-error\n\t\tthis.#reactivityTriggerObject[$TRACK]\n\n\t\treturn super.entries()\n\t}\n\n\toverride [Symbol.iterator](): IterableIterator<[string, PossibleBehaviorInstance]> {\n\t\t// track all properties in a Solid effect\n\t\t// @ts-expect-error\n\t\tthis.#reactivityTriggerObject[$TRACK]\n\n\t\treturn super[Symbol.iterator]()\n\t}\n\n\toverride forEach(\n\t\tcallbackfn: (value: PossibleBehaviorInstance, key: string, map: Map<string, PossibleBehaviorInstance>) => void,\n\t\tthisArg?: any,\n\t): void {\n\t\t// track all properties in a Solid effect\n\t\t// @ts-expect-error\n\t\tthis.#reactivityTriggerObject[$TRACK]\n\n\t\tsuper.forEach(callbackfn, thisArg)\n\t}\n\n\toverride keys(): IterableIterator<string> {\n\t\t// track all properties in a Solid effect\n\t\t// @ts-expect-error\n\t\tthis.#reactivityTriggerObject[$TRACK]\n\n\t\treturn super.keys()\n\t}\n\n\toverride get size(): number {\n\t\t// track all properties in a Solid effect\n\t\t// @ts-expect-error\n\t\tthis.#reactivityTriggerObject[$TRACK]\n\n\t\treturn super.size\n\t}\n\toverride set size(n: number) {\n\t\t// @ts-expect-error readonly property according to TS, but in JS it is\n\t\t// assignable though nothing happens. We need this so that the property\n\t\t// behaves the same after we override it.\n\t\tsuper.size = n\n\t}\n}\n\n// stores the behaviors associated to each element.\nconst behaviorMaps = new WeakMap()\n\n// All elements have a `behaviors` property. If null, it the element has no\n// behaviors, otherwise the property is a map of behavior names to behavior\n// instances.\nObject.defineProperty(Element.prototype, 'behaviors', {\n\tget() {\n\t\tlet thisBehaviors = null\n\n\t\tif (!behaviorMaps.has(this)) {\n\t\t\tbehaviorMaps.set(this, (thisBehaviors = new BehaviorMap()))\n\t\t} else thisBehaviors = behaviorMaps.get(this)\n\n\t\treturn thisBehaviors\n\t},\n})\n\nexport type ElementBehaviors = {behaviors: BehaviorMap}\n\nexport type ElementWithBehaviors = Element & ElementBehaviors\n\n// One instance of is instantiated per element with has=\"\" attribute.\nclass HasAttribute implements CustomAttribute {\n\t// properties defined by CustomAttribute\n\tdeclare ownerElement: ElementWithBehaviors\n\tdeclare value: string\n\tdeclare name: string\n\n\tget behaviors() {\n\t\treturn this.ownerElement.behaviors\n\t}\n\n\tobservers = new Map<PossibleBehaviorInstance, MutationObserver>()\n\telementDefinedPromises = new Map<string, CancelablePromise<CustomElementConstructor>>()\n\n\tisConnected = false // TODO move to base class\n\n\tconnectedCallback() {\n\t\tthis.isConnected = true\n\t\tthis.changedCallback('', this.value)\n\t}\n\n\tdisconnectedCallback() {\n\t\tthis.isConnected = false\n\t\tthis.#skipConnectedCheck = true\n\t\tthis.changedCallback(this.value, '')\n\t\tthis.#skipConnectedCheck = false\n\t}\n\n\t#skipConnectedCheck = false\n\n\tchangedCallback(oldVal: string, newVal: string) {\n\t\tif (!this.#skipConnectedCheck) {\n\t\t\tif (!this.isConnected) return\n\t\t}\n\n\t\tconst currentBehaviors = this.getBehaviorNames(newVal)\n\t\tconst previousBehaviors = this.getBehaviorNames(oldVal)\n\n\t\t// small optimization: if no previous or new behaviors, just quit\n\t\t// early. It would still function the same without this.\n\t\tif (currentBehaviors.length == 0 && previousBehaviors.length == 0) return\n\n\t\tconst {removed, added} = this.getDiff(previousBehaviors, currentBehaviors)\n\t\tthis.handleDiff(removed, added)\n\t}\n\n\tprivate getBehaviorNames(string: string) {\n\t\tif (string.trim() == '') return []\n\t\telse return string.split(/\\s+/)\n\t}\n\n\tprivate getDiff(previousBehaviors: string[], currentBehaviors: string[]) {\n\t\tconst diff = {\n\t\t\tremoved: [] as string[],\n\t\t\tadded: currentBehaviors,\n\t\t}\n\n\t\tfor (let i = 0, l = previousBehaviors.length; i < l; i += 1) {\n\t\t\tconst oldBehavior = previousBehaviors[i]\n\n\t\t\t// if it exists in the previousBehaviors but not the newBehaviors, then\n\t\t\t// the node was removed.\n\t\t\tif (!diff.added.includes(oldBehavior)) {\n\t\t\t\tdiff.removed.push(oldBehavior)\n\t\t\t}\n\n\t\t\t// otherwise the old value also exists in the set of new values, so\n\t\t\t// therefore it wasn't added or removed, so let's remove it so we\n\t\t\t// don't count it as added\n\t\t\telse {\n\t\t\t\tdiff.added.splice(diff.added.indexOf(oldBehavior), 1)\n\t\t\t}\n\t\t}\n\n\t\treturn diff\n\t}\n\n\tprivate handleDiff(removed: string[], added: string[]) {\n\t\tfor (const name of removed) this.disconnectBehavior(name)\n\t\tfor (const name of added) this.connectBehavior(name)\n\t}\n\n\tprivate async connectBehavior(name: string) {\n\t\tconst Behavior = elementBehaviors.get(name)\n\n\t\tif (!Behavior) return\n\n\t\tconst observedAttributes = Behavior.observedAttributes\n\n\t\tconst tagName = this.ownerElement.tagName\n\n\t\ttry {\n\t\t\t// if the element is a custom element and the behavior specifies to wait for it to be defined\n\t\t\tif (Behavior.awaitElementDefined && tagName.includes('-') && !customElements.get(tagName.toLowerCase())) {\n\t\t\t\tconst promiseId = name + '_' + tagName\n\t\t\t\tlet promise = this.elementDefinedPromises.get(promiseId)\n\n\t\t\t\tif (!promise) {\n\t\t\t\t\tpromise = new CancelablePromise(customElements.whenDefined(tagName.toLowerCase()), {\n\t\t\t\t\t\trejectOnCancel: true,\n\t\t\t\t\t})\n\t\t\t\t\tthis.elementDefinedPromises.set(promiseId, promise)\n\t\t\t\t}\n\n\t\t\t\tawait promise\n\t\t\t\tthis.elementDefinedPromises.delete(promiseId)\n\t\t\t}\n\n\t\t\tif (this.isConnected) {\n\t\t\t\tconst behavior = new Behavior(this.ownerElement)\n\t\t\t\tthis.behaviors.set(name, behavior)\n\t\t\t\tbehavior.connectedCallback?.(this.ownerElement)\n\n\t\t\t\tif (Array.isArray(observedAttributes) && observedAttributes.length) {\n\t\t\t\t\tthis.fireInitialAttributeChangedCallbacks(behavior, observedAttributes)\n\t\t\t\t\tthis.createAttributeObserver(behavior)\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tif (!(e instanceof PromiseCancellation)) throw e\n\n\t\t\t// do nothing if promise canceled\n\t\t}\n\t}\n\n\tprivate disconnectBehavior(name: string) {\n\t\tconst promiseId = name + '_' + this.ownerElement.tagName\n\t\tconst promise = this.elementDefinedPromises.get(promiseId)\n\n\t\tif (promise) {\n\t\t\tpromise.cancel()\n\t\t\tthis.elementDefinedPromises.delete(promiseId)\n\t\t}\n\n\t\tconst behavior = this.behaviors.get(name)\n\n\t\t// There will only be a behavior if connectBehavior both created it and\n\t\t// ran its connectedCallback.\n\t\tif (!behavior) return\n\n\t\tbehavior.disconnectedCallback?.(this.ownerElement)\n\t\tthis.destroyAttributeObserver(behavior)\n\t\tthis.behaviors.delete(name)\n\t}\n\n\tdestroyAttributeObserver(behavior: PossibleBehaviorInstance) {\n\t\tconst observer = this.observers.get(behavior)\n\t\tif (!observer) return\n\t\tobserver.disconnect()\n\t\tthis.observers.delete(behavior)\n\t}\n\n\t// Behaviors observe attribute changes, implemented with MutationObserver\n\t//\n\t// We have to create one observer per behavior because otherwise\n\t// MutationObserver doesn't have an API for disconnecting from a single\n\t// element, only for disconnecting from all elements.\n\tcreateAttributeObserver(behavior: PossibleBehaviorInstance) {\n\t\tconst el = this.ownerElement\n\n\t\tconst observer = new MutationObserver(records => {\n\t\t\tif (!behavior.attributeChangedCallback) return\n\n\t\t\t// Because we get mutations in order, and we have all the attribute\n\t\t\t// values for a given attribute along the way while iterating on\n\t\t\t// mutation records, we keep track of previous and current attribute\n\t\t\t// values (per attribute name) with this variable and thus we can\n\t\t\t// fire behavior.attributeChangedCallback with each previous and\n\t\t\t// current value. For why we need to do this, see\n\t\t\t// https://stackoverflow.com/questions/60593551.\n\t\t\tlet lastAttributeValues: {[k: string]: string | null} = {}\n\n\t\t\tlet name = ''\n\n\t\t\tfor (const record of records) {\n\t\t\t\tif (record.type !== 'attributes') continue\n\n\t\t\t\tname = record.attributeName!\n\n\t\t\t\tif (lastAttributeValues[name] === undefined) {\n\t\t\t\t\tlastAttributeValues[name] = record.oldValue\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tbehavior.attributeChangedCallback(name, lastAttributeValues[name], record.oldValue, this.ownerElement)\n\n\t\t\t\tlastAttributeValues[name] = record.oldValue\n\t\t\t}\n\n\t\t\tlet attr: Attr | null\n\n\t\t\tfor (const name in lastAttributeValues) {\n\t\t\t\tattr = el.attributes.getNamedItem(name)\n\t\t\t\tbehavior.attributeChangedCallback(\n\t\t\t\t\tname,\n\t\t\t\t\tlastAttributeValues[name],\n\t\t\t\t\tattr === null ? null : attr.value,\n\t\t\t\t\tthis.ownerElement,\n\t\t\t\t)\n\t\t\t}\n\t\t})\n\n\t\tobserver.observe(el, {\n\t\t\tattributes: true,\n\t\t\tattributeOldValue: true,\n\t\t\tattributeFilter: (behavior.constructor as PossibleBehaviorConstructor).observedAttributes,\n\t\t})\n\n\t\tthis.observers.set(behavior, observer)\n\t}\n\n\tfireInitialAttributeChangedCallbacks(behavior: PossibleBehaviorInstance, attributes: string[]) {\n\t\tif (!behavior.attributeChangedCallback) return\n\n\t\tfor (const name of attributes) {\n\t\t\tif (this.ownerElement.hasAttribute(name))\n\t\t\t\tbehavior.attributeChangedCallback(\n\t\t\t\t\tname,\n\t\t\t\t\tnull,\n\t\t\t\t\tthis.ownerElement.attributes.getNamedItem(name)!.value,\n\t\t\t\t\tthis.ownerElement,\n\t\t\t\t)\n\t\t}\n\t}\n}\n\n// TODO safe types for privates\nfunction Privates() {\n\tconst storage = new WeakMap()\n\n\treturn (obj: object) => {\n\t\tlet privates = storage.get(obj)\n\t\tif (!privates) storage.set(obj, (privates = {}))\n\t\treturn privates\n\t}\n}\n\nconst _ = Privates()\n\ninterface CancelablePromiseOptions {\n\trejectOnCancel?: boolean\n}\n\nclass CancelablePromise<T> extends Promise<T> {\n\tcanceled: boolean\n\n\tconstructor(\n\t\texecutor: Promise<T> | ((resolve: (value: T | PromiseLike<T>) => void, reject: (reason?: any) => void) => void),\n\t\toptions: CancelablePromiseOptions,\n\t) {\n\t\tconst rejectOnCancel = options ? options.rejectOnCancel : false\n\t\tlet originalReject\n\n\t\t// if the first arg is a promise-like\n\t\tif (executor instanceof Promise) {\n\t\t\tconst promise = executor\n\n\t\t\tsuper((resolve, reject) => {\n\t\t\t\toriginalReject = reject\n\n\t\t\t\tpromise\n\t\t\t\t\t.then(value => {\n\t\t\t\t\t\tif (this.canceled) return\n\t\t\t\t\t\tresolve(value)\n\t\t\t\t\t})\n\t\t\t\t\t.catch(error => {\n\t\t\t\t\t\tif (this.canceled) return\n\t\t\t\t\t\treject(error)\n\t\t\t\t\t})\n\t\t\t})\n\t\t} else {\n\t\t\tsuper((resolve, reject) => {\n\t\t\t\toriginalReject = reject\n\t\t\t\texecutor(\n\t\t\t\t\tvalue => {\n\t\t\t\t\t\tif (this.canceled) return\n\t\t\t\t\t\tresolve(value)\n\t\t\t\t\t},\n\t\t\t\t\terror => {\n\t\t\t\t\t\tif (this.canceled) return\n\t\t\t\t\t\treject(error)\n\t\t\t\t\t},\n\t\t\t\t)\n\t\t\t})\n\t\t}\n\n\t\tthis.canceled = false\n\t\t_(this).originalReject = originalReject\n\t\t_(this).rejectOnCancel = rejectOnCancel\n\t}\n\n\tcancel() {\n\t\tthis.canceled = true\n\n\t\tif (_(this).rejectOnCancel) {\n\t\t\t_(this).originalReject(new PromiseCancellation('canceled'))\n\t\t}\n\t}\n}\n\nclass PromiseCancellation extends Error {}\n\ncustomAttributes.define('has', HasAttribute)\n\n// TODO move this to custom-attributes\nif (Element.prototype.attachShadow) {\n\tconst _attachShadow = Element.prototype.attachShadow\n\n\tElement.prototype.attachShadow = function (...args) {\n\t\tconst root = _attachShadow.call(this, ...args)\n\t\tconst attributes = new CustomAttributeRegistry(root)\n\n\t\tattributes.define('has', HasAttribute)\n\n\t\treturn root\n\t}\n}\n\n// Leave this last line alone, it gets automatically updated when publishing a\n// new version of this package.\nexport const version = '3.0.2'\n"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","forEach","Array","CustomAttributeRegistry","constructor","ownerDocument","_attrMap","Map","_elementMap","WeakMap","_observer","MutationObserver","mutations","m","type","this","_getConstructor","attributeName","_handleChange","target","oldValue","removedNodes","_elementDisconnected","addedNodes","_elementConnected","element","nodeType","attributes","attr","name","_constructor","_upgradeAttr","map","inst","disconnectedCallback","delete","Error","define","attrName","Class","set","_reobserve","_observe","observe","childList","subtree","attributeOldValue","attributeFilter","keys","_unobserve","disconnect","node","matches","querySelectorAll","el","oldVal","newVal","getAttribute","ownerElement","connectedCallback","changedCallback","win","window","customAttributes","$customAttributes","skipPolyfill","document","$PROXY","$TRACK","signalOptions","equals","a","b","runEffects","runQueue","NOTPENDING","UNOWNED","owned","cleanups","context","owner","transPending","setTransPending","createSignal","Owner","Transition","Listener","Pending","Updates","Effects","ExecCount","options","assign","s","observers","observerSlots","pending","comparator","undefined","readSignal","bind","running","sources","has","tValue","writeSignal","createMemo","fn","c","createComputation","updateComputation","result","q","runUpdates","i","length","data","untrack","listener","getListener","children","resolveChildren","runningTransition","state","tState","updates","lookUpstream","sSlot","push","sourceSlots","isComp","TransitionRunning","add","disposed","pure","markDownstream","cleanNode","time","runComputation","queueMicrotask","nextValue","err","handleError","updatedAt","init","tOwned","runTop","suspense","inFallback","effects","ancestors","top","prev","wait","res","promises","size","queue","apply","resolve","e","d","v","len","completeUpdates","ignore","source","pop","index","obs","n","isArray","results","createProvider","id","props","defaultValue","createContext","$RAW","$NODE","$NAME","isWrappable","proto","getPrototypeOf","unwrap","item","Set","unwrapped","isFrozen","slice","l","desc","getOwnPropertyDescriptors","getDataNodes","nodes","getDataNode","property","createDataNode","trackSelf","_","internal","$","setProperty","proxyTraps","receiver","tracked","getOwnPropertyDescriptor","isFunction","args","wrap","deleteProperty","ownKeys","Reflect","configurable","writable","p","Proxy","og","$ROOT","applyState","parent","merge","previous","j","start","end","newEnd","newIndicesNext","keyVal","Math","min","temp","newIndices","targetKeys","previousKeys","reconcile","whenDefinedPromises","elementBehaviors","_definedBehaviors","Behavior","whenDefined","Promise","r","BehaviorMap","find","predicate","behavior","super","clear","modifier","entries","iterator","callbackfn","thisArg","behaviorMaps","Element","thisBehaviors","HasAttribute","elementDefinedPromises","isConnected","behaviors","currentBehaviors","getBehaviorNames","previousBehaviors","removed","added","getDiff","handleDiff","string","trim","split","diff","oldBehavior","includes","splice","indexOf","disconnectBehavior","connectBehavior","async","observedAttributes","tagName","awaitElementDefined","customElements","toLowerCase","promiseId","promise","CancelablePromise","rejectOnCancel","fireInitialAttributeChangedCallbacks","createAttributeObserver","PromiseCancellation","cancel","destroyAttributeObserver","observer","records","attributeChangedCallback","lastAttributeValues","record","getNamedItem","hasAttribute","storage","privates","Privates","executor","originalReject","reject","then","canceled","catch","error","attachShadow","_attachShadow","root"],"sourceRoot":""}