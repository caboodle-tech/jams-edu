{"version":3,"file":"global.js","mappings":"4DACA,I,EAAIA,EAAsB,CCA1BA,EAAwB,CAACC,EAASC,KACjC,IAAI,IAAIC,KAAOD,EACXF,EAAoBI,EAAEF,EAAYC,KAASH,EAAoBI,EAAEH,EAASE,IAC5EE,OAAOC,eAAeL,EAASE,EAAK,CAAEI,YAAY,EAAMC,IAAKN,EAAWC,IAE1E,ECNDH,EAAwB,CAACS,EAAKC,IAAUL,OAAOM,UAAUC,eAAeC,KAAKJ,EAAKC,GCClFV,EAAyBC,IACH,oBAAXa,QAA0BA,OAAOC,aAC1CV,OAAOC,eAAeL,EAASa,OAAOC,YAAa,CAAEC,MAAO,WAE7DX,OAAOC,eAAeL,EAAS,aAAc,CAAEe,OAAO,GAAO,G,sJCH9D,MAAMC,EAAUC,MAAMP,UAAUM,QAEzB,MAAME,EAmBZC,YAAmBC,GAClB,GADkB,KAAAA,cAAAA,EAlBX,KAAAC,SAAW,IAAIC,IACf,KAAAC,YAAc,IAAIC,QAElB,KAAAC,UAA8B,IAAIC,kBAAiBC,IAC1DX,EAAQJ,KAAKe,GAAYC,IACT,eAAXA,EAAEC,KACQC,KAAKC,gBAAgBH,EAAEI,gBAC1BF,KAAKG,cAAcL,EAAEI,cAAgBJ,EAAEM,OAAmBN,EAAEO,WAKtEnB,EAAQJ,KAAKgB,EAAEQ,aAAcN,KAAKO,sBAClCrB,EAAQJ,KAAKgB,EAAEU,WAAYR,KAAKS,mB,GAEhC,IAmDK,KAAAA,kBAAqBC,IACH,IAArBA,EAAQC,WAIZzB,EAAQJ,KAAK4B,EAAQE,YAAaC,IAC7Bb,KAAKC,gBAAgBY,EAAKC,OAAOd,KAAKG,cAAcU,EAAKC,KAAMJ,EAAS,KAAK,IAIlFV,KAAKT,SAASL,SAAQ,CAAC6B,EAAcF,IAASb,KAAKgB,aAAaH,EAAMH,KAAS,EAGxE,KAAAH,qBAAwBG,IAC/B,MAAMO,EAAMjB,KAAKP,YAAYhB,IAAIiC,GAC5BO,IAELA,EAAI/B,SAAQgC,IAAO,MAAC,OAAyB,QAAzB,EAAAA,EAAKC,4BAAoB,oBAAzBD,EAA6B,GAAElB,MAEnDA,KAAKP,YAAY2B,OAAOV,GAAQ,GAlE3BpB,EAAe,MAAM,IAAI+B,MAAM,2BACrC,CAEAC,OAAOC,EAAkBC,GACxBxB,KAAKT,SAASkC,IAAIF,EAAUC,GAC5BxB,KAAKgB,aAAaO,GAClBvB,KAAK0B,YACN,CAEAjD,IAAIiC,EAAkBa,GACrB,MAAMN,EAAMjB,KAAKP,YAAYhB,IAAIiC,GACjC,GAAKO,EACL,OAAOA,EAAIxC,IAAI8C,EAChB,CAEQtB,gBAAgBsB,GACvB,OAAOvB,KAAKT,SAASd,IAAI8C,EAC1B,CAEQI,WACP3B,KAAKL,UAAUiC,QAAQ5B,KAAKV,cAAe,CAC1CuC,WAAW,EACXC,SAAS,EACTlB,YAAY,EACZmB,mBAAmB,EACnBC,gBAAiB,IAAIhC,KAAKT,SAAS0C,SAGrC,CAEQC,aACPlC,KAAKL,UAAUwC,YAChB,CAEQT,aACP1B,KAAKkC,aACLlC,KAAK2B,UACN,CAEQX,aAAaO,EAAkBa,EAAwCpC,KAAKV,eACnF,MAAM+C,EAAUD,EAAKE,iBAAiB,IAAMf,EAAW,KAIvDrC,EAAQJ,KAAKuD,GAAU3B,GAAqBV,KAAKG,cAAcoB,EAAUb,EAAS,OACnF,CAwBQP,cAAcoB,EAAkBgB,EAAaC,G,UACpD,IAAIvB,EAAMjB,KAAKP,YAAYhB,IAAI8D,GAC1BtB,GAAKjB,KAAKP,YAAYgC,IAAIc,EAAKtB,EAAM,IAAIzB,KAE9C,IAAI0B,EAAOD,EAAIxC,IAAI8C,GACnB,MAAMkB,EAASF,EAAGG,aAAanB,GAG/B,IAAKL,EAAM,CAMV,GAJAA,EAAO,IADalB,KAAKC,gBAAgBsB,IAEzCN,EAAIQ,IAAIF,EAAUL,GAClBA,EAAKyB,aAAeJ,EACpBrB,EAAKJ,KAAOS,EACE,MAAVkB,EAAgB,MAAM,IAAIpB,MAAM,iBAGpC,OAFAH,EAAKjC,MAAQwD,OACS,QAAtB,EAAAvB,EAAK0B,yBAAiB,cAAtB1B,G,CAKD,GAAc,MAAVuB,EACsB,QAAzB,EAAAvB,EAAKC,4BAAoB,cAAzBD,GACAD,EAAIG,OAAOG,QAIP,GAAIkB,IAAWvB,EAAKjC,MAAO,CAE/B,GADAiC,EAAKjC,MAAQwD,EACC,MAAVD,EAAgB,MAAM,IAAInB,MAAM,iBAChB,QAApB,EAAAH,EAAK2B,uBAAe,cAApB3B,EAAuBsB,EAAQC,E,CAEjC,EAcD,GAAqB,QAAjB,EAAAK,WAAWC,cAAM,eAAEC,SAAU,CAChC,MAAMC,EAAgBC,QAAQtE,UAAUuE,aAExCD,QAAQtE,UAAUuE,aAAe,SAAsBC,GACtD,MAAMC,EAAOJ,EAAcnE,KAAKkB,KAAMoD,GAItC,OAFKC,EAAKC,mBAAkBD,EAAKC,iBAAmB,IAAIlE,EAAwBiE,IAEzEA,CACR,C,OC5IM,IAAIC,GAGU,QAAjB,EAAAR,WAAWC,cAAM,eAAEC,YAAUM,EAAmBR,WAAWQ,iBAAmB,IAAIlE,EAAwB4D,WCTvG,MAAMO,ECDN,WACN,MAAMC,EAAU,IAAI9D,QAEpB,OAAQhB,IACP,IAAI+E,EAAWD,EAAQ/E,IAAIC,GAE3B,OADK+E,GAAUD,EAAQ/B,IAAI/C,EAAM+E,EAAW,CAAC,GACtCA,CAAQ,CAEjB,CDPiBC,GAMV,MAAMC,UAA4BtC,OAElC,MAAMuC,UAA6BC,QAGzCxE,YACCyE,EACAV,GAEA,MAAMW,IAAiBX,GAAUA,EAAQW,eACzC,IAAIC,EAGJ,GAAIF,aAAoBD,QAAS,CAChC,MAAMI,EAAUH,EAEhBI,OAAM,CAACC,EAASC,KACfJ,EAAiBI,EAEjBH,EACEI,MAAKpF,IACDe,KAAKsE,UACTH,EAAQlF,EAAM,IAEdsF,OAAMC,IACFxE,KAAKsE,UACTF,EAAOI,EAAM,GACZ,G,MAGJN,OAAM,CAACC,EAASC,KACfJ,EAAiBI,EACjBN,GACC7E,IACKe,KAAKsE,UACTH,EAAQlF,EAAM,IAEfuF,IACKxE,KAAKsE,UACTF,EAAOI,EAAM,GAEd,IAIHxE,KAAKsE,UAAW,EAChBf,EAAEvD,MAAMgE,eAAiBA,EACzBT,EAAEvD,MAAM+D,eAAiBA,CAC1B,CAEAU,SACCzE,KAAKsE,UAAW,EAEZf,EAAEvD,MAAM+D,gBACXR,EAAEvD,MAAMgE,eAAe,IAAIL,EAAoB,YAEjD,EE+DD,MACMe,EAAS3F,OAAO,eAChB4F,EAAS5F,OAAO,eAEhB6F,GADW7F,OAAO,uBACF,CACpB8F,OALc,CAACC,EAAGC,IAAMD,IAAMC,IAOhC,IAAIC,EAAQ,KACRC,EAAaC,EACjB,MAAMC,EAAa,CAAC,EACdC,EAAQ,EACRC,EAAU,EACVC,EAAU,CACdC,MAAO,KACPC,SAAU,KACVC,QAAS,KACTC,MAAO,OAEFC,EAAcC,GAAgCC,GAAa,GAClE,IAAIC,EAAQ,KACZ,IAwYIC,EAxYAC,EAAa,KACbC,EAAY,KACZC,EAAwB,KACxBC,EAAW,KACXC,EAAU,KACVC,EAAU,KACVC,EAAU,KACVC,EAAY,EAqBhB,SAASV,EAAa5G,EAAOmE,GAC3BA,EAAUA,EAAU9E,OAAOkI,OAAO,CAAC,EAAG5B,EAAexB,GAAWwB,EAChE,MAAM6B,EAAI,CACRxH,QACAyH,UAAW,KACXC,cAAe,KACfC,QAASzB,EACT0B,WAAYzD,EAAQyB,aAAUiC,GAQhC,MAAO,CAACC,EAAWC,KAAKP,GANTxH,IACQ,mBAAVA,IAC0DA,EAA/D+G,GAAcA,EAAWiB,SAAWjB,EAAWkB,QAAQC,IAAIV,GAAYxH,EAAMwH,EAAEG,UAAYzB,EAAasB,EAAEG,QAAUH,EAAEW,QAAqBnI,EAAMwH,EAAEG,UAAYzB,EAAasB,EAAEG,QAAUH,EAAExH,QAEzLoI,EAAYZ,EAAGxH,IAG1B,CA+BA,SAASqI,EAAWC,EAAItI,EAAOmE,GAC7BA,EAAUA,EAAU9E,OAAOkI,OAAO,CAAC,EAAG5B,EAAexB,GAAWwB,EAChE,MAAM4C,EAAIC,EAAkBF,EAAItI,GAAO,EAAM,GAS7C,OARAuI,EAAEZ,QAAUzB,EACZqC,EAAEd,UAAY,KACdc,EAAEb,cAAgB,KAClBa,EAAEX,WAAazD,EAAQyB,aAAUiC,EAC7Bb,GAAaD,GAAcA,EAAWiB,SACxCO,EAAEE,OAAStC,EACXiB,EAAQsB,KAAKH,IACRI,EAAkBJ,GAClBT,EAAWC,KAAKQ,EACzB,CA+KA,SAAS,EAAMD,GACb,GAAInB,EAAS,OAAOmB,IACpB,IAAIM,EACJ,MAAMC,EAAI1B,EAAU,GACpB,IACEyB,EAASN,GACX,CAAE,QACAnB,EAAU,IACZ,CAWA,OAVA2B,GAAW,KACT,IAAK,IAAIC,EAAI,EAAGA,EAAIF,EAAEG,OAAQD,GAAK,EAAG,CACpC,MAAME,EAAOJ,EAAEE,GACf,GAAIE,EAAKtB,UAAYzB,EAAY,CAC/B,MAAMyB,EAAUsB,EAAKtB,QACrBsB,EAAKtB,QAAUzB,EACfkC,EAAYa,EAAMtB,EACpB,CACF,KACC,GACIiB,CACT,CACA,SAASM,EAAQZ,GACf,IAAIM,EACAO,EAAWjC,EAIf,OAHAA,EAAW,KACX0B,EAASN,IACTpB,EAAWiC,EACJP,CACT,CAiCA,SAASQ,IACP,OAAOlC,CACT,CA+DA,SAASmC,EAASf,GAChB,MAAMe,EAAWhB,EAAWC,GAC5B,OAAOD,GAAW,IAAMiB,EAAgBD,MAC1C,CAuBA,SAASvB,IACP,MAAMyB,EAAoBxC,GAAcA,EAAWiB,QACnD,GAAIjH,KAAKkH,WAAasB,GAAqBxI,KAAKyI,OAASD,GAAqBxI,KAAK0H,QAAS,CAC1F,MAAMgB,EAAUrC,EAChBA,EAAU,MACTmC,GAAqBxI,KAAKyI,QAAUrD,GAASoD,GAAqBxI,KAAK0H,SAAWtC,EAAQwC,EAAkB5H,MAAQ2I,EAAa3I,MAClIqG,EAAUqC,CACZ,CACA,GAAIvC,EAAU,CACZ,MAAMyC,EAAQ5I,KAAK0G,UAAY1G,KAAK0G,UAAUuB,OAAS,EAClD9B,EAASe,SAIZf,EAASe,QAAQS,KAAK3H,MACtBmG,EAAS0C,YAAYlB,KAAKiB,KAJ1BzC,EAASe,QAAU,CAAClH,MACpBmG,EAAS0C,YAAc,CAACD,IAKrB5I,KAAK0G,WAIR1G,KAAK0G,UAAUiB,KAAKxB,GACpBnG,KAAK2G,cAAcgB,KAAKxB,EAASe,QAAQe,OAAS,KAJlDjI,KAAK0G,UAAY,CAACP,GAClBnG,KAAK2G,cAAgB,CAACR,EAASe,QAAQe,OAAS,GAKpD,CACA,OAAIO,GAAqBxC,EAAWkB,QAAQC,IAAInH,MAAcA,KAAKoH,OAC5DpH,KAAKf,KACd,CACA,SAASoI,EAAYjF,EAAMnD,EAAO6J,GAChC,GAAI1C,EAGF,OAFIhE,EAAKwE,UAAYzB,GAAYiB,EAAQuB,KAAKvF,GAC9CA,EAAKwE,QAAU3H,EACRA,EAET,GAAImD,EAAKyE,WACP,GAAIb,GAAcA,EAAWiB,SAAWjB,EAAWkB,QAAQC,IAAI/E,IAC7D,GAAIA,EAAKyE,WAAWzE,EAAKgF,OAAQnI,GAAQ,OAAOA,OAC3C,GAAImD,EAAKyE,WAAWzE,EAAKnD,MAAOA,GAAQ,OAAOA,EAExD,IAAI8J,GAAoB,EA2BxB,OA1BI/C,GACF+C,EAAoB/C,EAAWiB,SAC3B8B,IAAsBD,GAAU9C,EAAWkB,QAAQC,IAAI/E,MACzD4D,EAAWkB,QAAQ8B,IAAI5G,GACvBA,EAAKgF,OAASnI,GAEX8J,IAAmB3G,EAAKnD,MAAQA,IAChCmD,EAAKnD,MAAQA,EAChBmD,EAAKsE,WAAatE,EAAKsE,UAAUuB,QACnCF,GAAW,KACT,IAAK,IAAIC,EAAI,EAAGA,EAAI5F,EAAKsE,UAAUuB,OAAQD,GAAK,EAAG,CACjD,MAAM3J,EAAI+D,EAAKsE,UAAUsB,GACrBe,GAAqB/C,EAAWiD,SAAS9B,IAAI9I,MAC7C0K,IAAsB1K,EAAEqJ,SAAWqB,IAAsB1K,EAAEoK,SACzDpK,EAAE6K,KAAM7C,EAAQsB,KAAKtJ,GAAQiI,EAAQqB,KAAKtJ,GAC1CA,EAAEqI,WAAWyC,EAAe9K,IAE9B0K,EAAmB1K,EAAEqJ,OAAStC,EAAW/G,EAAEoK,MAAQrD,EACzD,CACA,GAAIiB,EAAQ4B,OAAS,IAGnB,MAFA5B,EAAU,GAEJ,IAAIhF,KACZ,IACC,GAEEpC,CACT,CACA,SAAS2I,EAAkBxF,GACzB,IAAKA,EAAKmF,GAAI,OACd6B,EAAUhH,GACV,MAAMsD,EAAQI,EACRsC,EAAWjC,EACXkD,EAAO9C,EACbJ,EAAWL,EAAQ1D,EACnBkH,EAAelH,EAAM4D,GAAcA,EAAWiB,SAAWjB,EAAWkB,QAAQC,IAAI/E,GAAQA,EAAKgF,OAAShF,EAAKnD,MAAOoK,GAC9GrD,IAAeA,EAAWiB,SAAWjB,EAAWkB,QAAQC,IAAI/E,IAC9DmH,gBAAe,KACbxB,GAAW,KACT/B,IAAeA,EAAWiB,SAAU,GACpCqC,EAAelH,EAAMA,EAAKgF,OAAQiC,EAAK,IACtC,EAAM,IAGblD,EAAWiC,EACXtC,EAAQJ,CACV,CACA,SAAS4D,EAAelH,EAAMnD,EAAOoK,GACnC,IAAIG,EACJ,IACEA,EAAYpH,EAAKmF,GAAGtI,EACtB,CAAE,MAAOwK,GACPC,EAAYD,EACd,GACKrH,EAAKuH,WAAavH,EAAKuH,WAAaN,KACnCjH,EAAKsE,WAAatE,EAAKsE,UAAUuB,OACnCZ,EAAYjF,EAAMoH,GAAW,GACpBxD,GAAcA,EAAWiB,SAAW7E,EAAK8G,MAClDlD,EAAWkB,QAAQ8B,IAAI5G,GACvBA,EAAKgF,OAASoC,GACTpH,EAAKnD,MAAQuK,EACpBpH,EAAKuH,UAAYN,EAErB,CACA,SAAS5B,EAAkBF,EAAIqC,EAAMV,EAAMT,EAAQrD,EAAOhC,GACxD,MAAMoE,EAAI,CACRD,KACAkB,MAAOA,EACPkB,UAAW,KACXpE,MAAO,KACP2B,QAAS,KACT2B,YAAa,KACbrD,SAAU,KACVvG,MAAO2K,EACPlE,MAAOI,EACPL,QAAS,KACTyD,QAaF,GAXIlD,GAAcA,EAAWiB,UAC3BO,EAAEiB,MAAQ,EACVjB,EAAEE,OAASe,GAEC,OAAV3C,GAA0BA,IAAUR,IAClCU,GAAcA,EAAWiB,SAAWnB,EAAMoD,KACvCpD,EAAM+D,OAAgC/D,EAAM+D,OAAOlC,KAAKH,GAA1C1B,EAAM+D,OAAS,CAACrC,GAE9B1B,EAAMP,MAA8BO,EAAMP,MAAMoC,KAAKH,GAAxC1B,EAAMP,MAAQ,CAACiC,IAGjCtB,EAAuB,CACzB,MAAO4D,EAAOC,GAAWlE,OAAaiB,EAAW,CAC/CjC,QAAQ,IAEJmF,EAAW9D,EAAsBsB,EAAED,GAAIwC,IA1OjD,SAAmBxC,GACH,OAAVzB,IAA6C,OAAnBA,EAAMN,SAAmBM,EAAMN,SAAW,CAAC+B,GAASzB,EAAMN,SAASmC,KAAKJ,GAExG,CAwOI0C,EAAU,IAAMD,EAASE,YACzB,MAAMC,EAAsB,IAhNhC,SAAyB5C,GACvB,GAAIvB,GAAcA,EAAWiB,QAE3B,OADAM,IACOvB,EAAWoE,KAEpB,MAAMC,EAAIlE,EACJ9H,EAAIyH,EACV,OAAOjC,QAAQM,UAAUE,MAAK,KAG5B,IAAIiG,EAeJ,OAjBAnE,EAAWkE,EACXvE,EAAQzH,GAEJ4H,GAAaF,KACfuE,EAAItE,IAAeA,EAAa,CAC9BkB,QAAS,IAAIqD,IACbC,QAAS,GACTC,SAAU,IAAIF,IACdtB,SAAU,IAAIsB,IACdG,MAAO,IAAIH,IACXtD,SAAS,IAEXqD,EAAEF,OAASE,EAAEF,KAAO,IAAIvG,SAAQ8G,GAAOL,EAAEnG,QAAUwG,KACnDL,EAAErD,SAAU,GAEd,EAAMM,GACNpB,EAAWL,EAAQ,KACZwE,EAAIA,EAAEF,UAAOtD,CAAS,GAEjC,CAqLsC8D,CAAgBb,GAAS1F,MAAK,IAAMwG,EAAaX,YAC7EW,EAAe3E,EAAsBsB,EAAED,GAAI4C,GACjD3C,EAAED,GAAKuD,IACLhB,IACO9D,GAAcA,EAAWiB,QAAU4D,EAAaf,MAAMgB,GAAKd,EAASF,MAAMgB,GAErF,CACA,OAAOtD,CACT,CACA,SAASuD,EAAO3I,GACd,MAAMoG,EAAoBxC,GAAcA,EAAWiB,QACnD,IAAKuB,GAAoC,IAAfpG,EAAKqG,OAAeD,GAAqC,IAAhBpG,EAAKsF,OAAc,OACtF,IAAKc,GAAqBpG,EAAKqG,QAAUpD,GAAWmD,GAAqBpG,EAAKsF,SAAWrC,EAAS,OAAOsD,EAAavG,GACtH,GAAIA,EAAK4I,UAAY7C,EAAQ/F,EAAK4I,SAASC,YAAa,OAAO7I,EAAK4I,SAASR,QAAQ7C,KAAKvF,GAC1F,MAAM8I,EAAY,CAAC9I,GACnB,MAAQA,EAAOA,EAAKsD,UAAYtD,EAAKuH,WAAavH,EAAKuH,UAAYpD,IAAY,CAC7E,GAAIiC,GAAqBxC,EAAWiD,SAAS9B,IAAI/E,GAAO,SACnDoG,GAAqBpG,EAAKqG,OAASD,GAAqBpG,EAAKsF,SAAQwD,EAAUvD,KAAKvF,EAC3F,CACA,IAAK,IAAI4F,EAAIkD,EAAUjD,OAAS,EAAGD,GAAK,EAAGA,IAAK,CAE9C,GADA5F,EAAO8I,EAAUlD,GACbQ,EAAmB,CACrB,IAAI2C,EAAM/I,EACNgJ,EAAOF,EAAUlD,EAAI,GACzB,MAAQmD,EAAMA,EAAIzF,QAAUyF,IAAQC,GAClC,GAAIpF,EAAWiD,SAAS9B,IAAIgE,GAAM,MAEtC,CACA,IAAK3C,GAAqBpG,EAAKqG,QAAUrD,GAASoD,GAAqBpG,EAAKsF,SAAWtC,EACrFwC,EAAkBxF,QACb,IAAKoG,GAAqBpG,EAAKqG,QAAUpD,GAAWmD,GAAqBpG,EAAKsF,SAAWrC,EAAS,CACvG,MAAMqD,EAAUrC,EAChBA,EAAU,KACVsC,EAAavG,EAAM8I,EAAU,IAC7B7E,EAAUqC,CACZ,CACF,CACF,CACA,SAASX,EAAWR,EAAIqC,GACtB,GAAIvD,EAAS,OAAOkB,IACpB,IAAI8D,GAAO,EACNzB,IAAMvD,EAAU,IACjBC,EAAS+E,GAAO,EAAU/E,EAAU,GACxCC,IACA,IACE,MAAMoE,EAAMpD,IAEZ,OAMJ,SAAyB8D,GAKvB,GAJIhF,IACEJ,GAAaD,GAAcA,EAAWiB,QA+C9C,SAAuByD,GACrB,IAAK,IAAI1C,EAAI,EAAGA,EAAI0C,EAAMzC,OAAQD,IAAK,CACrC,MAAMsD,EAAOZ,EAAM1C,GACbuD,EAAQvF,EAAW0E,MACpBa,EAAMpE,IAAImE,KACbC,EAAMvC,IAAIsC,GACVrF,GAAU,KACRsF,EAAMnK,OAAOkK,GACbvD,GAAW,KACT/B,EAAWiB,SAAU,EACrB8D,EAAOO,GACFC,EAAMC,OACTlF,EAAQqB,KAAK8D,MAAMnF,EAASN,EAAWwE,SACvCxE,EAAWwE,QAAU,GACvB,IACC,GACHxE,IAAeA,EAAWiB,SAAU,EAAM,IAGhD,CACF,CAnEuDyE,CAAcrF,GAAcnB,EAASmB,GACxFA,EAAU,MAERgF,EAAM,OACV,IAAIV,EACJ,GAAI3E,GAAcA,EAAWiB,QAAS,CACpC,GAAIjB,EAAWyE,SAASe,MAAQxF,EAAW0E,MAAMc,KAK/C,OAJAxF,EAAWiB,SAAU,EACrBjB,EAAWwE,QAAQ7C,KAAK8D,MAAMzF,EAAWwE,QAASlE,GAClDA,EAAU,UACVV,GAAgB,GAGlB,MAAMsB,EAAUlB,EAAWkB,QACrB+B,EAAWjD,EAAWiD,SAC5B0B,EAAM3E,EAAW7B,QACjB,IAAK,MAAMwH,KAAKrF,EACd,WAAYqF,IAAMA,EAAElD,MAAQkD,EAAEjE,eACvBiE,EAAEjE,OAEX1B,EAAa,KACb,GAAM,KACJ,IAAK,MAAM4F,KAAK3C,EAAUG,EAAUwC,GACpC,IAAK,MAAMC,KAAK3E,EAAS,CAEvB,GADA2E,EAAE5M,MAAQ4M,EAAEzE,OACRyE,EAAEtG,MACJ,IAAK,IAAIyC,EAAI,EAAG8D,EAAMD,EAAEtG,MAAM0C,OAAQD,EAAI8D,EAAK9D,IAAKoB,EAAUyC,EAAEtG,MAAMyC,IAEpE6D,EAAEhC,SAAQgC,EAAEtG,MAAQsG,EAAEhC,eACnBgC,EAAEzE,cACFyE,EAAEhC,OACTgC,EAAEnE,OAAS,CACb,CACA9B,GAAgB,EAAM,GAE1B,CACIU,EAAQ2B,OAAQ,GAAM,KACxBhD,EAAWqB,GACXA,EAAU,IAAI,IAEdA,EAAU,KAERqE,GAAKA,GACX,CApDIoB,CAAgBV,GACTV,CACT,CAAE,MAAOlB,GACFpD,IAASC,EAAU,MACxBoD,EAAYD,EACd,CACF,CA+CA,SAASvE,EAASwF,GAChB,IAAK,IAAI1C,EAAI,EAAGA,EAAI0C,EAAMzC,OAAQD,IAAK+C,EAAOL,EAAM1C,GACtD,CAkCA,SAASW,EAAavG,EAAM4J,GAC1B,MAAMxD,EAAoBxC,GAAcA,EAAWiB,QAC/CuB,EAAmBpG,EAAKsF,OAAS,EAAOtF,EAAKqG,MAAQ,EACzD,IAAK,IAAIT,EAAI,EAAGA,EAAI5F,EAAK8E,QAAQe,OAAQD,GAAK,EAAG,CAC/C,MAAMiE,EAAS7J,EAAK8E,QAAQc,GACxBiE,EAAO/E,WACJsB,GAAqByD,EAAOxD,QAAUrD,GAASoD,GAAqByD,EAAOvE,SAAWtC,EACrF6G,IAAWD,GAAQjB,EAAOkB,KACpBzD,GAAqByD,EAAOxD,QAAUpD,GAAWmD,GAAqByD,EAAOvE,SAAWrC,IAASsD,EAAasD,EAAQD,GAEtI,CACF,CACA,SAAS7C,EAAe/G,GACtB,MAAMoG,EAAoBxC,GAAcA,EAAWiB,QACnD,IAAK,IAAIe,EAAI,EAAGA,EAAI5F,EAAKsE,UAAUuB,OAAQD,GAAK,EAAG,CACjD,MAAM3J,EAAI+D,EAAKsE,UAAUsB,KACpBQ,IAAsBnK,EAAEoK,OAASD,IAAsBnK,EAAEqJ,UACxDc,EAAmBnK,EAAEqJ,OAASrC,EAAahH,EAAEoK,MAAQpD,EACrDhH,EAAE6K,KAAM7C,EAAQsB,KAAKtJ,GAAQiI,EAAQqB,KAAKtJ,GAC9CA,EAAEqI,WAAayC,EAAe9K,GAElC,CACF,CACA,SAAS+K,EAAUhH,GACjB,IAAI4F,EACJ,GAAI5F,EAAK8E,QACP,KAAO9E,EAAK8E,QAAQe,QAAQ,CAC1B,MAAMgE,EAAS7J,EAAK8E,QAAQgF,MACtBC,EAAQ/J,EAAKyG,YAAYqD,MACzBE,EAAMH,EAAOvF,UACnB,GAAI0F,GAAOA,EAAInE,OAAQ,CACrB,MAAMoE,EAAID,EAAIF,MACRzF,EAAIwF,EAAOtF,cAAcuF,MAC3BC,EAAQC,EAAInE,SACdoE,EAAExD,YAAYpC,GAAK0F,EACnBC,EAAID,GAASE,EACbJ,EAAOtF,cAAcwF,GAAS1F,EAElC,CACF,CAEF,GAAIT,GAAcA,EAAWiB,SAAW7E,EAAK8G,KAAM,CACjD,GAAI9G,EAAKyH,OAAQ,CACf,IAAK7B,EAAI,EAAGA,EAAI5F,EAAKyH,OAAO5B,OAAQD,IAAKoB,EAAUhH,EAAKyH,OAAO7B,WACxD5F,EAAKyH,MACd,CACA,EAAMzH,GAAM,EACd,MAAO,GAAIA,EAAKmD,MAAO,CACrB,IAAKyC,EAAI,EAAGA,EAAI5F,EAAKmD,MAAM0C,OAAQD,IAAKoB,EAAUhH,EAAKmD,MAAMyC,IAC7D5F,EAAKmD,MAAQ,IACf,CACA,GAAInD,EAAKoD,SAAU,CACjB,IAAKwC,EAAI,EAAGA,EAAI5F,EAAKoD,SAASyC,OAAQD,IAAK5F,EAAKoD,SAASwC,KACzD5F,EAAKoD,SAAW,IAClB,CACIQ,GAAcA,EAAWiB,QAAS7E,EAAKsF,OAAS,EAAOtF,EAAKqG,MAAQ,EACxErG,EAAKqD,QAAU,IACjB,CACA,SAAS,EAAMrD,EAAM+I,GAKnB,GAJKA,IACH/I,EAAKsF,OAAS,EACd1B,EAAWiD,SAASD,IAAI5G,IAEtBA,EAAKmD,MACP,IAAK,IAAIyC,EAAI,EAAGA,EAAI5F,EAAKmD,MAAM0C,OAAQD,IAAK,EAAM5F,EAAKmD,MAAMyC,GAEjE,CACA,SAAS0B,EAAYD,GACnB,MAAM6C,EAAMtH,GAASuH,EAAOzG,EAAOd,GACnC,IAAKsH,EAAK,MAAM7C,EAChB,IAAK,MAAM+C,KAAKF,EAAKE,EAAE/C,EACzB,CACA,SAAS8C,EAAO7G,EAAOtH,GACrB,OAAOsH,EAAQA,EAAMD,cAAkCqB,IAAvBpB,EAAMD,QAAQrH,GAAqBsH,EAAMD,QAAQrH,GAAOmO,EAAO7G,EAAMA,MAAOtH,QAAO0I,CACrH,CACA,SAASyB,EAAgBD,GACvB,GAAwB,mBAAbA,IAA4BA,EAASL,OAAQ,OAAOM,EAAgBD,KAC/E,GAAInJ,MAAMsN,QAAQnE,GAAW,CAC3B,MAAMoE,EAAU,GAChB,IAAK,IAAI1E,EAAI,EAAGA,EAAIM,EAASL,OAAQD,IAAK,CACxC,MAAMH,EAASU,EAAgBD,EAASN,IACxC7I,MAAMsN,QAAQ5E,GAAU6E,EAAQ/E,KAAK8D,MAAMiB,EAAS7E,GAAU6E,EAAQ/E,KAAKE,EAC7E,CACA,OAAO6E,CACT,CACA,OAAOpE,CACT,CACA,SAASqE,EAAeC,GACtB,OAAO,SAAkBC,GACvB,IAAIlC,EAOJ,OA/tBJ,SAAwBpD,EAAItI,EAAOmE,GACjC,MAAMoE,EAAIC,EAAkBF,EAAItI,GAAO,EAAMmG,GACzCa,GAAaD,GAAcA,EAAWiB,QAASZ,EAAQsB,KAAKH,GAAQI,EAAkBJ,EAC5F,CAstBIsF,EAAe,IAAMnC,EAAMxC,GAAQ,KACjCrC,EAAML,QAAU,CACd,CAACmH,GAAKC,EAAM5N,OAEPqJ,GAAS,IAAMuE,EAAMvE,gBAEvBqC,CACT,CACF,CA+CiB5L,OAAO,YArcxB,SAAuBgO,GACrB,MAAMH,EAAK7N,OAAO,WAGN4N,EAAeC,EAG7B,CA2zB4BI,GC30C5B,MAAMC,EAAOlO,OAAO,aACdmO,GAAQnO,OAAO,cACfoO,GAAQpO,OAAO,cAqBrB,SAASqO,GAAY1O,GACnB,IAAI2O,EACJ,OAAc,MAAP3O,GAA8B,iBAARA,IAAqBA,EAAIgG,MAAa2I,EAAQ/O,OAAOgP,eAAe5O,KAAS2O,IAAU/O,OAAOM,WAAaO,MAAMsN,QAAQ/N,GACxJ,CACA,SAAS6O,GAAOjC,EAAM7J,EAAM,IAAI8I,KAC9B,IAAI1C,EAAQ2F,EAAW3B,EAAGlN,EAC1B,GAAIkJ,EAAiB,MAARyD,GAAgBA,EAAK2B,GAAO,OAAOpF,EAChD,IAAKuF,GAAY9B,IAAS7J,EAAI0F,IAAImE,GAAO,OAAOA,EAChD,GAAInM,MAAMsN,QAAQnB,GAAO,CACnBhN,OAAOmP,SAASnC,GAAOA,EAAOA,EAAKoC,MAAM,GAAQjM,EAAIuH,IAAIsC,GAC7D,IAAK,IAAItD,EAAI,EAAGqC,EAAIiB,EAAKrD,OAAQD,EAAIqC,EAAGrC,IACtC6D,EAAIP,EAAKtD,IACJwF,EAAYD,GAAO1B,EAAGpK,MAAUoK,IAAGP,EAAKtD,GAAKwF,EAEtD,KAAO,CACDlP,OAAOmP,SAASnC,GAAOA,EAAOhN,OAAOkI,OAAO,CAAC,EAAG8E,GAAW7J,EAAIuH,IAAIsC,GACvE,MAAMrJ,EAAO3D,OAAO2D,KAAKqJ,GACnBqC,EAAOrP,OAAOsP,0BAA0BtC,GAC9C,IAAK,IAAItD,EAAI,EAAGqC,EAAIpI,EAAKgG,OAAQD,EAAIqC,EAAGrC,IACtCrJ,EAAOsD,EAAK+F,GACR2F,EAAKhP,GAAMF,MACfoN,EAAIP,EAAK3M,IACJ6O,EAAYD,GAAO1B,EAAGpK,MAAUoK,IAAGP,EAAK3M,GAAQ6O,GAEzD,CACA,OAAOlC,CACT,CACA,SAASuC,GAAazN,GACpB,IAAI0N,EAAQ1N,EAAO8M,IAInB,OAHKY,GAAOxP,OAAOC,eAAe6B,EAAQ8M,GAAO,CAC/CjO,MAAO6O,EAAQ,CAAC,IAEXA,CACT,CACA,SAASC,GAAYD,EAAOE,EAAU/O,GACpC,OAAO6O,EAAME,KAAcF,EAAME,GAAYC,GAAehP,GAAO,GACrE,CASA,SAASiP,GAAU9N,GACjB,GAAIiI,IAAe,CACjB,MAAMyF,EAAQD,GAAazN,IAC1B0N,EAAMvK,IAAMuK,EAAMvK,EAAI0K,QACzB,CACF,CAKA,SAASA,GAAehP,EAAO4F,GAC7B,MAAO4B,EAAGhF,GAAOoE,EAAa5G,EAAO4F,EAAS,CAC5CsJ,UAAU,GACR,CACFtJ,QAAQ,EACRsJ,UAAU,IAGZ,OADA1H,EAAE2H,EAAI3M,EACCgF,CACT,CAyBA,SAAS4H,GAAY5F,EAAOuF,EAAU/O,GACpC,GAAIwJ,EAAMuF,KAAc/O,EAAO,OAC/B,MAAMmM,EAAO3C,EAAMuF,GACblC,EAAMrD,EAAMR,YACJnB,IAAV7H,SACKwJ,EAAMuF,GACRvF,EAAMuF,GAAY/O,EACzB,IACImD,EADA0L,EAAQD,GAAapF,IAErBrG,EAAO2L,GAAYD,EAAOE,EAAU5C,KAAOhJ,EAAKgM,GAAE,IAAMnP,IACxDE,MAAMsN,QAAQhE,IAAUA,EAAMR,SAAW6D,IAAM1J,EAAO2L,GAAYD,EAAO,SAAUhC,KAAS1J,EAAKgM,EAAE3F,EAAMR,SAC5G7F,EAAO0L,EAAMvK,IAAMnB,EAAKgM,GAC3B,CA+EA,MAAME,GAAa,CACjB7P,IAAI2B,EAAQ4N,EAAUO,GACpB,GAAIP,IAAaf,EAAM,OAAO7M,EAC9B,GAAI4N,IAAatJ,EAAQ,OAAO6J,EAChC,GAAIP,IAAarJ,EAAQ,OAAOuJ,GAAU9N,GAC1C,MAAM0N,EAAQD,GAAazN,GACrBoO,EAAUV,EAAME,GACtB,IAAI/O,EAAQuP,EAAUV,EAAME,KAAc5N,EAAO4N,GACjD,GAAIA,IAAad,IAAsB,cAAbc,EAA0B,OAAO/O,EAC3D,IAAKuP,EAAS,CACZ,MAAMb,EAAOrP,OAAOmQ,yBAAyBrO,EAAQ4N,GAC/CU,EAA8B,mBAAVzP,EAC1B,IAAIoJ,KAAmBqG,IAActO,EAAOvB,eAAemP,IAAgBL,GAAQA,EAAKlP,KAAyD,GAAa,MAATQ,GAAiByP,GAAczP,IAAUE,MAAMP,UAAUoP,GAC5M,MAAO,IAAIW,IAAS,GAAM,IAAMxP,MAAMP,UAAUoP,GAAUvC,MAAM8C,EAAUI,UADkB1P,EAAQ8O,GAAYD,EAAOE,EAAU/O,EAA7B8O,EAGxG,CACA,OAAOX,GAAYnO,GAAS2P,GAAK3P,GAASA,CAC5C,EACAwC,IAAG,CAACrB,EAAQ4N,EAAU/O,KACpB,GAAM,IAAMoP,GAAYjO,EAAQ4N,EAAUT,GAAOtO,OAC1C,GAET4P,eAAc,CAACzO,EAAQ4N,KACrB,GAAM,IAAMK,GAAYjO,EAAQ4N,OAAUlH,MACnC,GAETgI,QA3JF,SAAiB1O,GAEf,OADA8N,GAAU9N,GACH2O,QAAQD,QAAQ1O,EACzB,EAyJEqO,yBA1KF,SAAyBrO,EAAQ4N,GAC/B,MAAML,EAAOoB,QAAQN,yBAAyBrO,EAAQ4N,GACtD,OAAKL,IAAQA,EAAKlP,KAAQkP,EAAKqB,cAAgBhB,IAAatJ,GAAUsJ,IAAad,IAASc,IAAab,WAClGQ,EAAK1O,aACL0O,EAAKsB,SACZtB,EAAKlP,IAAM,IAAM2B,EAAOsE,GAAQsJ,GACzBL,GAJgHA,CAKzH,GAqKA,SAASiB,GAAK3P,EAAO6B,GACnB,IAAIoO,EAAIjQ,EAAMyF,GACd,IAAKwK,EAAG,CACN5Q,OAAOC,eAAeU,EAAOyF,EAAQ,CACnCzF,MAAOiQ,EAAI,IAAIC,MAAMlQ,EAAOqP,MAE9B,MAAMrM,EAAO3D,OAAO2D,KAAKhD,GACnB0O,EAAOrP,OAAOsP,0BAA0B3O,GAC9C,IAAK,IAAI+I,EAAI,EAAGqC,EAAIpI,EAAKgG,OAAQD,EAAIqC,EAAGrC,IAAK,CAC3C,MAAMrJ,EAAOsD,EAAK+F,GAClB,GAAI2F,EAAKhP,GAAMF,IAAK,CAClB,MAAMA,EAAMkP,EAAKhP,GAAMF,IAAIuI,KAAKkI,GAChC5Q,OAAOC,eAAeU,EAAON,EAAM,CACjCF,OAEJ,CACA,GAAIkP,EAAKhP,GAAM8C,IAAK,CAClB,MAAM2N,EAAKzB,EAAKhP,GAAM8C,IAChBA,EAAMoK,GAAK,GAAM,IAAMuD,EAAGtQ,KAAKoQ,EAAGrD,KACxCvN,OAAOC,eAAeU,EAAON,EAAM,CACjC8C,OAEJ,CACF,CACF,CACA,OAAOyN,CACT,CAUA,MAAMG,GAAQtQ,OAAO,cACrB,SAASuQ,GAAWlP,EAAQmP,EAAQvB,EAAUwB,EAAOpR,GACnD,MAAMqR,EAAWF,EAAOvB,GACxB,GAAI5N,IAAWqP,EAAU,OACzB,IAAKrC,GAAYhN,KAAYgN,GAAYqC,IAAarR,GAAOgC,EAAOhC,KAASqR,EAASrR,GAAM,CAC1F,GAAIgC,IAAWqP,EAAU,CACvB,GAAIzB,IAAaqB,GAAO,OAAOjP,EAC/BiO,GAAYkB,EAAQvB,EAAU5N,EAChC,CACA,MACF,CACA,GAAIjB,MAAMsN,QAAQrM,GAAS,CACzB,GAAIA,EAAO6H,QAAUwH,EAASxH,UAAYuH,GAASpR,GAAyB,MAAlBgC,EAAO,GAAGhC,IAAe,CACjF,IAAI4J,EAAG0H,EAAGC,EAAOC,EAAKC,EAAQvE,EAAMwE,EAAgBC,EACpD,IAAKJ,EAAQ,EAAGC,EAAMI,KAAKC,IAAIR,EAASxH,OAAQ7H,EAAO6H,QAAS0H,EAAQC,IAAQH,EAASE,KAAWvP,EAAOuP,IAAUvR,GAAOqR,EAASE,GAAOvR,KAASgC,EAAOuP,GAAOvR,IAAOuR,IACxKL,GAAWlP,EAAOuP,GAAQF,EAAUE,EAAOH,EAAOpR,GAEpD,MAAM8R,EAAO,IAAI/Q,MAAMiB,EAAO6H,QACxBkI,EAAa,IAAI3Q,IACvB,IAAKoQ,EAAMH,EAASxH,OAAS,EAAG4H,EAASzP,EAAO6H,OAAS,EAAG2H,GAAOD,GAASE,GAAUF,IAAUF,EAASG,KAASxP,EAAOyP,IAAWzR,GAAOqR,EAASG,GAAKxR,KAASgC,EAAOyP,GAAQzR,IAAOwR,IAAOC,IAC7LK,EAAKL,GAAUJ,EAASG,GAE1B,GAAID,EAAQE,GAAUF,EAAQC,EAAK,CACjC,IAAKF,EAAIC,EAAOD,GAAKG,EAAQH,IAAKrB,GAAYoB,EAAUC,EAAGtP,EAAOsP,IAClE,KAAOA,EAAItP,EAAO6H,OAAQyH,IACxBrB,GAAYoB,EAAUC,EAAGQ,EAAKR,IAC9BJ,GAAWlP,EAAOsP,GAAID,EAAUC,EAAGF,EAAOpR,GAG5C,YADIqR,EAASxH,OAAS7H,EAAO6H,QAAQoG,GAAYoB,EAAU,SAAUrP,EAAO6H,QAE9E,CAEA,IADA6H,EAAiB,IAAI3Q,MAAM0Q,EAAS,GAC/BH,EAAIG,EAAQH,GAAKC,EAAOD,IAC3BpE,EAAOlL,EAAOsP,GACdK,EAAS3R,EAAMkN,EAAKlN,GAAOkN,EAC3BtD,EAAImI,EAAW1R,IAAIsR,GACnBD,EAAeJ,QAAW5I,IAANkB,GAAmB,EAAIA,EAC3CmI,EAAW1O,IAAIsO,EAAQL,GAEzB,IAAK1H,EAAI2H,EAAO3H,GAAK4H,EAAK5H,IACxBsD,EAAOmE,EAASzH,GAChB+H,EAAS3R,EAAMkN,EAAKlN,GAAOkN,EAC3BoE,EAAIS,EAAW1R,IAAIsR,QACTjJ,IAAN4I,IAA0B,IAAPA,IACrBQ,EAAKR,GAAKD,EAASzH,GACnB0H,EAAII,EAAeJ,GACnBS,EAAW1O,IAAIsO,EAAQL,IAG3B,IAAKA,EAAIC,EAAOD,EAAItP,EAAO6H,OAAQyH,IAC7BA,KAAKQ,GACP7B,GAAYoB,EAAUC,EAAGQ,EAAKR,IAC9BJ,GAAWlP,EAAOsP,GAAID,EAAUC,EAAGF,EAAOpR,IACrCiQ,GAAYoB,EAAUC,EAAGtP,EAAOsP,GAE3C,MACE,IAAK,IAAI1H,EAAI,EAAG8D,EAAM1L,EAAO6H,OAAQD,EAAI8D,EAAK9D,IAC5CsH,GAAWlP,EAAO4H,GAAIyH,EAAUzH,EAAGwH,EAAOpR,GAI9C,YADIqR,EAASxH,OAAS7H,EAAO6H,QAAQoG,GAAYoB,EAAU,SAAUrP,EAAO6H,QAE9E,CACA,MAAMmI,EAAa9R,OAAO2D,KAAK7B,GAC/B,IAAK,IAAI4H,EAAI,EAAG8D,EAAMsE,EAAWnI,OAAQD,EAAI8D,EAAK9D,IAChDsH,GAAWlP,EAAOgQ,EAAWpI,IAAKyH,EAAUW,EAAWpI,GAAIwH,EAAOpR,GAEpE,MAAMiS,EAAe/R,OAAO2D,KAAKwN,GACjC,IAAK,IAAIzH,EAAI,EAAG8D,EAAMuE,EAAapI,OAAQD,EAAI8D,EAAK9D,SAClBlB,IAA5B1G,EAAOiQ,EAAarI,KAAmBqG,GAAYoB,EAAUY,EAAarI,QAAIlB,EAEtF,CACA,SAASwJ,GAAUrR,EAAOmE,EAAU,CAAC,GACnC,MAAM,MACJoM,EAAK,IACLpR,EAAM,MACJgF,EACEyI,EAAI0B,GAAOtO,GACjB,OAAOwJ,IACL,IAAK2E,GAAY3E,KAAW2E,GAAYvB,GAAI,OAAOA,EACnD,MAAMlB,EAAM2E,GAAWzD,EAAG,CACxB,CAACwD,IAAQ5G,GACR4G,GAAOG,EAAOpR,GACjB,YAAe0I,IAAR6D,EAAoBlC,EAAQkC,CAAG,CAE1C,CACkB,IAAIjL,Q,kTC1Vf,MAAM6Q,WAAoB/Q,IAAjC,c,oBACC,YD4PsBoP,GADErB,GC3P2D,CAAC,GD2P5C,CAAC,IC9I1C,CA3GCiD,KAAKC,GACJ,IAAI5I,EAEJ,IAAK,MAAO/G,EAAM4P,KAAa1Q,KAC9B,GAAKyQ,EAAU3P,EAAM4P,GAArB,CACA7I,EAAS6I,EACT,KAFwC,CAKzC,OAAO7I,CACR,CAESpJ,IAAIL,GAIZ,OAFA,GAAA4B,KAAI,QAA0B5B,GAEvB8F,MAAMzF,IAAIL,EAClB,CAESqD,IAAIrD,EAAaa,GASzB,OARAsK,gBAAe,KAEd,GAAAvJ,KAAI,QAA0B5B,GAAOa,CAAK,IAK3CiF,MAAMzC,IAAIrD,EAAKa,GACRe,IACR,CAESoB,OAAOhD,GAMf,OALAmL,gBAAe,YAEP,GAAAvJ,KAAI,QAA0B5B,EAAI,IAGnC8F,MAAM9C,OAAOhD,EACrB,CAESuS,QACRpH,gBAAe,KDoNjB,IAAuBd,EAAOmI,EAAPnI,EClNN,GAAAzI,KAAI,QDkNS4Q,EClNkBN,GAAU,CAAC,GDmNzD,GAAM,IAAMM,EAASrD,GAAO9E,KCnNgC,IAG5DvE,MAAMyM,OACP,CAESxJ,IAAI/I,GAOZ,OAFA,GAAA4B,KAAI,QAA0B5B,GAEvB8F,MAAMiD,IAAI/I,EAClB,CAESyS,UAKR,OAFA,GAAA7Q,KAAI,QAA0B2E,GAEvBT,MAAM2M,SACd,CAES,iBAAC9R,OAAO+R,aAKhB,OAFA,GAAA9Q,KAAI,QAA0B2E,GAEvBT,MAAMnF,OAAO+R,WACrB,CAES5R,QACR6R,EACAC,GAIA,GAAAhR,KAAI,QAA0B2E,GAE9BT,MAAMhF,QAAQ6R,EAAYC,EAC3B,CAES/O,OAKR,OAFA,GAAAjC,KAAI,QAA0B2E,GAEvBT,MAAMjC,MACd,CAEauJ,WAKZ,OAFA,GAAAxL,KAAI,QAA0B2E,GAEvBT,MAAMsH,IACd,CACaA,SAAKa,GAIjBnI,MAAMsH,KAAOa,CACd,E,wXC7GM,MAAM4E,GAAb,cAUC,KAAAvK,UAAY,IAAIlH,IAChB,KAAA0R,uBAAyB,IAAI1R,IAE7B,KAAA2R,aAAc,EAkBd,aAAsB,EAsMvB,CA/NKC,gBACH,OAAOpR,KAAK2C,aAAayO,SAC1B,CAWAxO,oBACC5C,KAAKmR,aAAc,EACnBnR,KAAK6C,gBAAgB,GAAI7C,KAAKf,MAC/B,CAEAkC,uBACCnB,KAAKmR,aAAc,EACnB,GAAAnR,KAAI,IAAuB,EAAI,KAC/BA,KAAK6C,gBAAgB7C,KAAKf,MAAO,IACjC,GAAAe,KAAI,IAAuB,EAAK,IACjC,CAIA6C,gBAAgBL,EAAgBC,GAC/B,I,uSAAK,CAAAzC,KAAI,UACHA,KAAKmR,YAAa,OAGxB,MAAME,EAAmBrR,KAAKsR,iBAAiB7O,GACzC8O,EAAoBvR,KAAKsR,iBAAiB9O,GAIhD,GAA+B,GAA3B6O,EAAiBpJ,QAA2C,GAA5BsJ,EAAkBtJ,OAAa,OAEnE,MAAM,QAACuJ,EAAO,MAAEC,GAASzR,KAAK0R,QAAQH,EAAmBF,GACzDrR,KAAK2R,WAAWH,EAASC,EAC1B,CAEQH,iBAAiBM,GACxB,MAAqB,IAAjBA,EAAOC,OAAqB,GACpBD,EAAOE,MAAM,MAC1B,CAEQJ,QAAQH,EAA6BF,GAC5C,MAAMU,EAAO,CACZP,QAAS,GACTC,MAAOJ,GAGR,IAAK,IAAIrJ,EAAI,EAAGqC,EAAIkH,EAAkBtJ,OAAQD,EAAIqC,EAAGrC,GAAK,EAAG,CAC5D,MAAMgK,EAAcT,EAAkBvJ,GAIjC+J,EAAKN,MAAMQ,SAASD,GAQxBD,EAAKN,MAAMS,OAAOH,EAAKN,MAAMU,QAAQH,GAAc,GAPnDD,EAAKP,QAAQ7J,KAAKqK,E,CAWpB,OAAOD,CACR,CAEQJ,WAAWH,EAAmBC,GACrC,IAAK,MAAM3Q,KAAQ0Q,EAASxR,KAAKoS,mBAAmBtR,GACpD,IAAK,MAAMA,KAAQ2Q,EAAOzR,KAAKqS,gBAAgBvR,EAChD,CAEQwR,sBAAsBxR,G,MAC7B,MAAMyR,EAAWC,iBAAiB/T,IAAIqC,GAEtC,IAAKyR,EAAU,OAIf,MAAME,EAAqBF,EAASE,mBAE9BC,EAAU1S,KAAK2C,aAAa+P,QAElC,IAEC,GAAIH,EAASI,qBAAuBD,EAAQT,SAAS,OAASW,eAAenU,IAAIiU,EAAQG,eAAgB,CACxG,MAAMC,EAAYhS,EAAO,IAAM4R,EAC/B,IAAIzO,EAAUjE,KAAKkR,uBAAuBzS,IAAIqU,GAEzC7O,IACJA,EAAU,IAAIL,EAAkBgP,eAAeG,YAAYL,EAAQG,eAAgB,CAClF9O,gBAAgB,IAEjB/D,KAAKkR,uBAAuBzP,IAAIqR,EAAW7O,UAGtCA,EACNjE,KAAKkR,uBAAuB9P,OAAO0R,E,CAGpC,GAAI9S,KAAKmR,YAAa,CACrB,MAAMT,EAAW,IAAI6B,EAASvS,KAAK2C,cACnC3C,KAAKoR,UAAU3P,IAAIX,EAAM4P,GACC,QAA1B,EAAAA,EAAS9N,yBAAiB,cAA1B8N,EAA6B1Q,KAAK2C,cAE9BxD,MAAMsN,QAAQgG,IAAuBA,EAAmBxK,SAC3DjI,KAAKgT,qCAAqCtC,EAAU+B,GACpDzS,KAAKiT,wBAAwBvC,G,EAG9B,MAAO/E,GACR,KAAMA,aAAahI,GAAsB,MAAMgI,C,CAIjD,CAEQyG,mBAAmBtR,G,MAC1B,MAAMgS,EAAYhS,EAAO,IAAMd,KAAK2C,aAAa+P,QAC3CzO,EAAUjE,KAAKkR,uBAAuBzS,IAAIqU,GAE5C7O,IACHA,EAAQQ,SACRzE,KAAKkR,uBAAuB9P,OAAO0R,IAGpC,MAAMpC,EAAW1Q,KAAKoR,UAAU3S,IAAIqC,GAI/B4P,IAEwB,QAA7B,EAAAA,EAASvP,4BAAoB,cAA7BuP,EAAgC1Q,KAAK2C,cACrC3C,KAAKkT,yBAAyBxC,GAC9B1Q,KAAKoR,UAAUhQ,OAAON,GACvB,CAEAoS,yBAAyBxC,GACxB,MAAMyC,EAAWnT,KAAK0G,UAAUjI,IAAIiS,GAC/ByC,IACLA,EAAShR,aACTnC,KAAK0G,UAAUtF,OAAOsP,GACvB,CAOAuC,wBAAwBvC,GACvB,MAAMnO,EAAKvC,KAAK2C,aAEVwQ,EAAW,IAAIvT,kBAAiBwT,IACrC,IAAK1C,EAAS2C,yBAA0B,OASxC,IAmBIxS,EAnBAyS,EAAoD,CAAC,EAErDxS,EAAO,GAEX,IAAK,MAAMyS,KAAUH,EACA,eAAhBG,EAAOxT,OAEXe,EAAOyS,EAAOrT,mBAEoB4G,IAA9BwM,EAAoBxS,IAKxB4P,EAAS2C,yBAAyBvS,EAAMwS,EAAoBxS,GAAOyS,EAAOlT,SAAUL,KAAK2C,cAEzF2Q,EAAoBxS,GAAQyS,EAAOlT,UANlCiT,EAAoBxS,GAAQyS,EAAOlT,UAWrC,IAAK,MAAMS,KAAQwS,EAClBzS,EAAO0B,EAAG3B,WAAW4S,aAAa1S,GAClC4P,EAAS2C,yBACRvS,EACAwS,EAAoBxS,GACX,OAATD,EAAgB,KAAOA,EAAK5B,MAC5Be,KAAK2C,a,IAKRwQ,EAASvR,QAAQW,EAAI,CACpB3B,YAAY,EACZmB,mBAAmB,EACnBC,gBAAkB0O,EAASrR,YAA4CoT,qBAGxEzS,KAAK0G,UAAUjF,IAAIiP,EAAUyC,EAC9B,CAEAH,qCAAqCtC,EAAoC9P,GACxE,GAAK8P,EAAS2C,yBAEd,IAAK,MAAMvS,KAAQF,EACdZ,KAAK2C,aAAa8Q,aAAa3S,IAClC4P,EAAS2C,yBACRvS,EACA,KACAd,KAAK2C,aAAa/B,WAAW4S,aAAa1S,GAAO7B,MACjDe,KAAK2C,aAGT,EAID,G,eAAqB,QAAjB,GAAAG,WAAWC,cAAM,iBAAEC,SAAU,CAEhC,MAAM0Q,EAAe,IAAIhU,QAEzBpB,OAAOC,eAAe2E,QAAQtE,UAAW,YAAa,CACrDH,MACC,IAAIkV,EAAgB,KAMpB,OAJKD,EAAavM,IAAInH,MAEf2T,EAAgBD,EAAajV,IAAIuB,MADvC0T,EAAajS,IAAIzB,KAAO2T,EAAgB,IAAIpD,IAGtCoD,CACR,IAGD,MAAM1Q,EAAgBC,QAAQtE,UAAUuE,aAExCD,QAAQtE,UAAUuE,aAAe,SAAUC,GAC1C,MAAMC,EAAOJ,EAAcnE,KAAKkB,KAAMoD,GAItC,OAFAC,EAAKC,iBAAiBhC,OAAO,MAAO2P,IAE7B5N,CACR,EAEAP,WAAWQ,iBAAiBhC,OAAO,MAAO2P,G,CCzQpC,MAAM2C,GAAkD,IAAIpU,IAE5D,MAAMqU,GAAb,cACW,KAAAC,kBAAoB,IAAItU,GAmCnC,CAjCC8B,OAA8CR,EAAcyR,GAC3D,GAAKvS,KAAK8T,kBAAkB3M,IAAIrG,GAG/B,MAAM,IAAIO,MAAM,YAAYP,yBAF5Bd,KAAK8T,kBAAkBrS,IAAIX,EAAMyR,EAInC,CAEA9T,IAAIqC,GACH,OAAOd,KAAK8T,kBAAkBrV,IAAIqC,EACnC,CAEAqG,IAAIrG,GACH,OAAOd,KAAK8T,kBAAkB3M,IAAIrG,EACnC,CAOAiS,YAAYjS,GACX,IAAIqD,EACJ,MAAM+K,EAAI,IAAIrL,SAAckQ,GAAM5P,EAAU4P,IAQ5C,OANK/T,KAAKmH,IAAIrG,GAGbqD,IAFAyP,GAAoBnS,IAAIX,EAAMoO,GAKxBA,CACR,EAGM,IAAI,IAGU,QAAjB,GAAApM,WAAWC,cAAM,iBAAEC,YACtB,GAAmBF,WAAW0P,iBAAmB,IAAIqB,ICrC/C,MAAM,GAAU,Q","sources":["webpack://__IGNORE_THIS_PLACEHOLDER_VARIABLE__/webpack/bootstrap","webpack://__IGNORE_THIS_PLACEHOLDER_VARIABLE__/webpack/runtime/define property getters","webpack://__IGNORE_THIS_PLACEHOLDER_VARIABLE__/webpack/runtime/hasOwnProperty shorthand","webpack://__IGNORE_THIS_PLACEHOLDER_VARIABLE__/webpack/runtime/make namespace object","webpack://__IGNORE_THIS_PLACEHOLDER_VARIABLE__/./node_modules/@lume/custom-attributes/src/CustomAttributeRegistry.ts","webpack://__IGNORE_THIS_PLACEHOLDER_VARIABLE__/./node_modules/@lume/custom-attributes/src/index.ts","webpack://__IGNORE_THIS_PLACEHOLDER_VARIABLE__/./src/CancelablePromise.ts","webpack://__IGNORE_THIS_PLACEHOLDER_VARIABLE__/./src/Privates.ts","webpack://__IGNORE_THIS_PLACEHOLDER_VARIABLE__/./node_modules/solid-js/dist/solid.js","webpack://__IGNORE_THIS_PLACEHOLDER_VARIABLE__/./node_modules/solid-js/store/dist/store.js","webpack://__IGNORE_THIS_PLACEHOLDER_VARIABLE__/./src/BehaviorMap.ts","webpack://__IGNORE_THIS_PLACEHOLDER_VARIABLE__/./src/HasAttribute.ts","webpack://__IGNORE_THIS_PLACEHOLDER_VARIABLE__/./src/BehaviorRegistry.ts","webpack://__IGNORE_THIS_PLACEHOLDER_VARIABLE__/./src/index.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import type {Constructor} from 'lowclass'\n\nconst forEach = Array.prototype.forEach\n\nexport class CustomAttributeRegistry {\n\tprivate _attrMap = new Map<string, Constructor>()\n\tprivate _elementMap = new WeakMap<Element, Map<string, CustomAttribute>>()\n\n\tprivate _observer: MutationObserver = new MutationObserver(mutations => {\n\t\tforEach.call(mutations, (m: MutationRecord) => {\n\t\t\tif (m.type === 'attributes') {\n\t\t\t\tconst attr = this._getConstructor(m.attributeName!)\n\t\t\t\tif (attr) this._handleChange(m.attributeName!, m.target as Element, m.oldValue)\n\t\t\t}\n\n\t\t\t// chlidList\n\t\t\telse {\n\t\t\t\tforEach.call(m.removedNodes, this._elementDisconnected)\n\t\t\t\tforEach.call(m.addedNodes, this._elementConnected)\n\t\t\t}\n\t\t})\n\t})\n\n\tconstructor(public ownerDocument: Document | ShadowRoot) {\n\t\tif (!ownerDocument) throw new Error('Must be given a document')\n\t}\n\n\tdefine(attrName: string, Class: Constructor) {\n\t\tthis._attrMap.set(attrName, Class)\n\t\tthis._upgradeAttr(attrName)\n\t\tthis._reobserve()\n\t}\n\n\tget(element: Element, attrName: string) {\n\t\tconst map = this._elementMap.get(element)\n\t\tif (!map) return\n\t\treturn map.get(attrName)\n\t}\n\n\tprivate _getConstructor(attrName: string) {\n\t\treturn this._attrMap.get(attrName)\n\t}\n\n\tprivate _observe() {\n\t\tthis._observer.observe(this.ownerDocument, {\n\t\t\tchildList: true,\n\t\t\tsubtree: true,\n\t\t\tattributes: true,\n\t\t\tattributeOldValue: true,\n\t\t\tattributeFilter: [...this._attrMap.keys()],\n\t\t\t// attributeFilter: this._attrMap.keys(), // This works in Chrome, but TS complains, and not clear if it should work in all browsers yet: https://github.com/whatwg/dom/issues/1092\n\t\t})\n\t}\n\n\tprivate _unobserve() {\n\t\tthis._observer.disconnect()\n\t}\n\n\tprivate _reobserve() {\n\t\tthis._unobserve()\n\t\tthis._observe()\n\t}\n\n\tprivate _upgradeAttr(attrName: string, node: Element | Document | ShadowRoot = this.ownerDocument) {\n\t\tconst matches = node.querySelectorAll('[' + attrName + ']')\n\n\t\t// Possibly create custom attributes that may be in the given 'node' tree.\n\t\t// Use a forEach as Edge doesn't support for...of on a NodeList\n\t\tforEach.call(matches, (element: Element) => this._handleChange(attrName, element, null))\n\t}\n\n\tprivate _elementConnected = (element: Element) => {\n\t\tif (element.nodeType !== 1) return\n\n\t\t// For each of the connected element's attribute, possibly instantiate the custom attributes.\n\t\t// Use a forEach as Safari 10 doesn't support for...of on NamedNodeMap (attributes)\n\t\tforEach.call(element.attributes, (attr: Attr) => {\n\t\t\tif (this._getConstructor(attr.name)) this._handleChange(attr.name, element, null)\n\t\t})\n\n\t\t// Possibly instantiate custom attributes that may be in the subtree of the connected element.\n\t\tthis._attrMap.forEach((_constructor, attr) => this._upgradeAttr(attr, element))\n\t}\n\n\tprivate _elementDisconnected = (element: Element) => {\n\t\tconst map = this._elementMap.get(element)\n\t\tif (!map) return\n\n\t\tmap.forEach(inst => inst.disconnectedCallback?.(), this)\n\n\t\tthis._elementMap.delete(element)\n\t}\n\n\tprivate _handleChange(attrName: string, el: Element, oldVal: string | null) {\n\t\tlet map = this._elementMap.get(el)\n\t\tif (!map) this._elementMap.set(el, (map = new Map()))\n\n\t\tlet inst = map.get(attrName)\n\t\tconst newVal = el.getAttribute(attrName)\n\n\t\t// Attribute is being created\n\t\tif (!inst) {\n\t\t\tconst Constructor = this._getConstructor(attrName)!\n\t\t\tinst = new Constructor() as CustomAttribute\n\t\t\tmap.set(attrName, inst)\n\t\t\tinst.ownerElement = el\n\t\t\tinst.name = attrName\n\t\t\tif (newVal == null) throw new Error('Not possible!')\n\t\t\tinst.value = newVal\n\t\t\tinst.connectedCallback?.()\n\t\t\treturn\n\t\t}\n\n\t\t// Attribute was removed\n\t\tif (newVal == null) {\n\t\t\tinst.disconnectedCallback?.()\n\t\t\tmap.delete(attrName)\n\t\t}\n\n\t\t// Attribute changed\n\t\telse if (newVal !== inst.value) {\n\t\t\tinst.value = newVal\n\t\t\tif (oldVal == null) throw new Error('Not possible!')\n\t\t\tinst.changedCallback?.(oldVal, newVal)\n\t\t}\n\t}\n}\n\n// TODO Replace with a class that extends from `Attr` for alignment with the web platform?\nexport interface CustomAttribute {\n\townerElement: Element\n\tname: string\n\tvalue: string\n\tconnectedCallback?(): void\n\tdisconnectedCallback?(): void\n\tchangedCallback?(oldValue: string, newValue: string): void\n}\n\n// Avoid errors trying to use DOM APIs in non-DOM environments (f.e. server-side rendering).\nif (globalThis.window?.document) {\n\tconst _attachShadow = Element.prototype.attachShadow\n\n\tElement.prototype.attachShadow = function attachShadow(options) {\n\t\tconst root = _attachShadow.call(this, options)\n\n\t\tif (!root.customAttributes) root.customAttributes = new CustomAttributeRegistry(root)\n\n\t\treturn root\n\t}\n}\n","// TODO We don't know when a ShadowRoot is no longer referenced, hence we cannot\n// unobserve them. Verify that MOs are cleaned up once ShadowRoots are no longer\n// referenced.\n\nimport {CustomAttributeRegistry} from './CustomAttributeRegistry.js'\n\nexport * from './CustomAttributeRegistry.js'\n\nexport let customAttributes: CustomAttributeRegistry\n\n// Avoid errors trying to use DOM APIs in non-DOM environments (f.e. server-side rendering).\nif (globalThis.window?.document) customAttributes = globalThis.customAttributes = new CustomAttributeRegistry(document)\n\ndeclare global {\n\t// const doesn't always work (TS bug). At time of writing this, it doesn't work in this TS playground example:\n\t// https://www.typescriptlang.org/play?#code/KYDwDg9gTgLgBAbzgXwFCoCbAMYBsCGUwcA5rhAEb66KpxzYQB2AzvAGYQQBccTArgFsKwKKjSoylagBUAFgEsWAOk4Q4Aeg1wAolCjQANHAXwYipgGsWcAAZrbJm0wjws7BU2AYgA\n\t// And discussions:\n\t// https://discord.com/channels/508357248330760243/508357248330760249/1019034094060978228\n\t// https://discord.com/channels/508357248330760243/1019017621397585961\n\tvar customAttributes: CustomAttributeRegistry\n\n\tinterface ShadowRoot {\n\t\tcustomAttributes: CustomAttributeRegistry\n\t}\n\n\tinterface Window {\n\t\tcustomAttributes: CustomAttributeRegistry\n\t}\n}\n\nexport const version = '0.1.5'\n","import {Privates} from './Privates.js'\n\nexport const _ = Privates()\n\nexport interface CancelablePromiseOptions {\n\trejectOnCancel?: boolean\n}\n\nexport class PromiseCancellation extends Error {}\n\nexport class CancelablePromise<T> extends Promise<T> {\n\tcanceled: boolean\n\n\tconstructor(\n\t\texecutor: Promise<T> | ((resolve: (value: T | PromiseLike<T>) => void, reject: (reason?: any) => void) => void),\n\t\toptions: CancelablePromiseOptions,\n\t) {\n\t\tconst rejectOnCancel = options ? options.rejectOnCancel : false\n\t\tlet originalReject\n\n\t\t// if the first arg is a promise-like\n\t\tif (executor instanceof Promise) {\n\t\t\tconst promise = executor\n\n\t\t\tsuper((resolve, reject) => {\n\t\t\t\toriginalReject = reject\n\n\t\t\t\tpromise\n\t\t\t\t\t.then(value => {\n\t\t\t\t\t\tif (this.canceled) return\n\t\t\t\t\t\tresolve(value)\n\t\t\t\t\t})\n\t\t\t\t\t.catch(error => {\n\t\t\t\t\t\tif (this.canceled) return\n\t\t\t\t\t\treject(error)\n\t\t\t\t\t})\n\t\t\t})\n\t\t} else {\n\t\t\tsuper((resolve, reject) => {\n\t\t\t\toriginalReject = reject\n\t\t\t\texecutor(\n\t\t\t\t\tvalue => {\n\t\t\t\t\t\tif (this.canceled) return\n\t\t\t\t\t\tresolve(value)\n\t\t\t\t\t},\n\t\t\t\t\terror => {\n\t\t\t\t\t\tif (this.canceled) return\n\t\t\t\t\t\treject(error)\n\t\t\t\t\t},\n\t\t\t\t)\n\t\t\t})\n\t\t}\n\n\t\tthis.canceled = false\n\t\t_(this).originalReject = originalReject\n\t\t_(this).rejectOnCancel = rejectOnCancel\n\t}\n\n\tcancel() {\n\t\tthis.canceled = true\n\n\t\tif (_(this).rejectOnCancel) {\n\t\t\t_(this).originalReject(new PromiseCancellation('canceled'))\n\t\t}\n\t}\n}\n","// TODO safe types for privates\nexport function Privates() {\n\tconst storage = new WeakMap()\n\n\treturn (obj: object) => {\n\t\tlet privates = storage.get(obj)\n\t\tif (!privates) storage.set(obj, (privates = {}))\n\t\treturn privates\n\t}\n}\n","let taskIdCounter = 1,\n    isCallbackScheduled = false,\n    isPerformingWork = false,\n    taskQueue = [],\n    currentTask = null,\n    shouldYieldToHost = null,\n    yieldInterval = 5,\n    deadline = 0,\n    maxYieldInterval = 300,\n    scheduleCallback = null,\n    scheduledCallback = null;\nconst maxSigned31BitInt = 1073741823;\nfunction setupScheduler() {\n  const channel = new MessageChannel(),\n        port = channel.port2;\n  scheduleCallback = () => port.postMessage(null);\n  channel.port1.onmessage = () => {\n    if (scheduledCallback !== null) {\n      const currentTime = performance.now();\n      deadline = currentTime + yieldInterval;\n      const hasTimeRemaining = true;\n      try {\n        const hasMoreWork = scheduledCallback(hasTimeRemaining, currentTime);\n        if (!hasMoreWork) {\n          scheduledCallback = null;\n        } else port.postMessage(null);\n      } catch (error) {\n        port.postMessage(null);\n        throw error;\n      }\n    }\n  };\n  if (navigator && navigator.scheduling && navigator.scheduling.isInputPending) {\n    const scheduling = navigator.scheduling;\n    shouldYieldToHost = () => {\n      const currentTime = performance.now();\n      if (currentTime >= deadline) {\n        if (scheduling.isInputPending()) {\n          return true;\n        }\n        return currentTime >= maxYieldInterval;\n      } else {\n        return false;\n      }\n    };\n  } else {\n    shouldYieldToHost = () => performance.now() >= deadline;\n  }\n}\nfunction enqueue(taskQueue, task) {\n  function findIndex() {\n    let m = 0;\n    let n = taskQueue.length - 1;\n    while (m <= n) {\n      const k = n + m >> 1;\n      const cmp = task.expirationTime - taskQueue[k].expirationTime;\n      if (cmp > 0) m = k + 1;else if (cmp < 0) n = k - 1;else return k;\n    }\n    return m;\n  }\n  taskQueue.splice(findIndex(), 0, task);\n}\nfunction requestCallback(fn, options) {\n  if (!scheduleCallback) setupScheduler();\n  let startTime = performance.now(),\n      timeout = maxSigned31BitInt;\n  if (options && options.timeout) timeout = options.timeout;\n  const newTask = {\n    id: taskIdCounter++,\n    fn,\n    startTime,\n    expirationTime: startTime + timeout\n  };\n  enqueue(taskQueue, newTask);\n  if (!isCallbackScheduled && !isPerformingWork) {\n    isCallbackScheduled = true;\n    scheduledCallback = flushWork;\n    scheduleCallback();\n  }\n  return newTask;\n}\nfunction cancelCallback(task) {\n  task.fn = null;\n}\nfunction flushWork(hasTimeRemaining, initialTime) {\n  isCallbackScheduled = false;\n  isPerformingWork = true;\n  try {\n    return workLoop(hasTimeRemaining, initialTime);\n  } finally {\n    currentTask = null;\n    isPerformingWork = false;\n  }\n}\nfunction workLoop(hasTimeRemaining, initialTime) {\n  let currentTime = initialTime;\n  currentTask = taskQueue[0] || null;\n  while (currentTask !== null) {\n    if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || shouldYieldToHost())) {\n      break;\n    }\n    const callback = currentTask.fn;\n    if (callback !== null) {\n      currentTask.fn = null;\n      const didUserCallbackTimeout = currentTask.expirationTime <= currentTime;\n      callback(didUserCallbackTimeout);\n      currentTime = performance.now();\n      if (currentTask === taskQueue[0]) {\n        taskQueue.shift();\n      }\n    } else taskQueue.shift();\n    currentTask = taskQueue[0] || null;\n  }\n  return currentTask !== null;\n}\n\nconst sharedConfig = {};\nfunction setHydrateContext(context) {\n  sharedConfig.context = context;\n}\nfunction nextHydrateContext() {\n  return { ...sharedConfig.context,\n    id: `${sharedConfig.context.id}${sharedConfig.context.count++}-`,\n    count: 0\n  };\n}\n\nconst equalFn = (a, b) => a === b;\nconst $PROXY = Symbol(\"solid-proxy\");\nconst $TRACK = Symbol(\"solid-track\");\nconst $DEVCOMP = Symbol(\"solid-dev-component\");\nconst signalOptions = {\n  equals: equalFn\n};\nlet ERROR = null;\nlet runEffects = runQueue;\nconst NOTPENDING = {};\nconst STALE = 1;\nconst PENDING = 2;\nconst UNOWNED = {\n  owned: null,\n  cleanups: null,\n  context: null,\n  owner: null\n};\nconst [transPending, setTransPending] = /*@__PURE__*/createSignal(false);\nvar Owner = null;\nlet Transition = null;\nlet Scheduler = null;\nlet ExternalSourceFactory = null;\nlet Listener = null;\nlet Pending = null;\nlet Updates = null;\nlet Effects = null;\nlet ExecCount = 0;\nfunction createRoot(fn, detachedOwner) {\n  const listener = Listener,\n        owner = Owner,\n        unowned = fn.length === 0,\n        root = unowned && !false ? UNOWNED : {\n    owned: null,\n    cleanups: null,\n    context: null,\n    owner: detachedOwner || owner\n  },\n        updateFn = unowned ? fn : () => fn(() => cleanNode(root));\n  Owner = root;\n  Listener = null;\n  try {\n    return runUpdates(updateFn, true);\n  } finally {\n    Listener = listener;\n    Owner = owner;\n  }\n}\nfunction createSignal(value, options) {\n  options = options ? Object.assign({}, signalOptions, options) : signalOptions;\n  const s = {\n    value,\n    observers: null,\n    observerSlots: null,\n    pending: NOTPENDING,\n    comparator: options.equals || undefined\n  };\n  const setter = value => {\n    if (typeof value === \"function\") {\n      if (Transition && Transition.running && Transition.sources.has(s)) value = value(s.pending !== NOTPENDING ? s.pending : s.tValue);else value = value(s.pending !== NOTPENDING ? s.pending : s.value);\n    }\n    return writeSignal(s, value);\n  };\n  return [readSignal.bind(s), setter];\n}\nfunction createComputed(fn, value, options) {\n  const c = createComputation(fn, value, true, STALE);\n  if (Scheduler && Transition && Transition.running) Updates.push(c);else updateComputation(c);\n}\nfunction createRenderEffect(fn, value, options) {\n  const c = createComputation(fn, value, false, STALE);\n  if (Scheduler && Transition && Transition.running) Updates.push(c);else updateComputation(c);\n}\nfunction createEffect(fn, value, options) {\n  runEffects = runUserEffects;\n  const c = createComputation(fn, value, false, STALE),\n        s = SuspenseContext && lookup(Owner, SuspenseContext.id);\n  if (s) c.suspense = s;\n  c.user = true;\n  Effects ? Effects.push(c) : updateComputation(c);\n}\nfunction createReaction(onInvalidate, options) {\n  let fn;\n  const c = createComputation(() => {\n    fn ? fn() : untrack(onInvalidate);\n    fn = undefined;\n  }, undefined, false, 0),\n        s = SuspenseContext && lookup(Owner, SuspenseContext.id);\n  if (s) c.suspense = s;\n  c.user = true;\n  return tracking => {\n    fn = tracking;\n    updateComputation(c);\n  };\n}\nfunction createMemo(fn, value, options) {\n  options = options ? Object.assign({}, signalOptions, options) : signalOptions;\n  const c = createComputation(fn, value, true, 0);\n  c.pending = NOTPENDING;\n  c.observers = null;\n  c.observerSlots = null;\n  c.comparator = options.equals || undefined;\n  if (Scheduler && Transition && Transition.running) {\n    c.tState = STALE;\n    Updates.push(c);\n  } else updateComputation(c);\n  return readSignal.bind(c);\n}\nfunction createResource(source, fetcher, options) {\n  if (arguments.length === 2) {\n    if (typeof fetcher === \"object\") {\n      options = fetcher;\n      fetcher = source;\n      source = true;\n    }\n  } else if (arguments.length === 1) {\n    fetcher = source;\n    source = true;\n  }\n  options || (options = {});\n  const contexts = new Set(),\n        [value, setValue] = createSignal(options.initialValue),\n        [track, trigger] = createSignal(undefined, {\n    equals: false\n  }),\n        [loading, setLoading] = createSignal(false),\n        [error, setError] = createSignal();\n  let err = undefined,\n      pr = null,\n      initP = null,\n      id = null,\n      loadedUnderTransition = false,\n      scheduled = false,\n      resolved = (\"initialValue\" in options),\n      dynamic = typeof source === \"function\" && createMemo(source);\n  if (sharedConfig.context) {\n    id = `${sharedConfig.context.id}${sharedConfig.context.count++}`;\n    if (sharedConfig.load) initP = sharedConfig.load(id);\n  }\n  function loadEnd(p, v, e, key) {\n    if (pr === p) {\n      pr = null;\n      resolved = true;\n      if (initP && (p === initP || v === initP) && options.onHydrated) queueMicrotask(() => options.onHydrated(key, {\n        value: v\n      }));\n      initP = null;\n      setError(err = e);\n      if (Transition && p && loadedUnderTransition) {\n        Transition.promises.delete(p);\n        loadedUnderTransition = false;\n        runUpdates(() => {\n          Transition.running = true;\n          if (!Transition.promises.size) {\n            Effects.push.apply(Effects, Transition.effects);\n            Transition.effects = [];\n          }\n          completeLoad(v);\n        }, false);\n      } else completeLoad(v);\n    }\n    return v;\n  }\n  function completeLoad(v) {\n    batch(() => {\n      setValue(() => v);\n      setLoading(false);\n      for (const c of contexts.keys()) c.decrement();\n      contexts.clear();\n    });\n  }\n  function read() {\n    const c = SuspenseContext && lookup(Owner, SuspenseContext.id),\n          v = value();\n    if (err) throw err;\n    if (Listener && !Listener.user && c) {\n      createComputed(() => {\n        track();\n        if (pr) {\n          if (c.resolved && Transition) Transition.promises.add(pr);else if (!contexts.has(c)) {\n            c.increment();\n            contexts.add(c);\n          }\n        }\n      });\n    }\n    return v;\n  }\n  function load(refetching = true) {\n    if (refetching && scheduled) return;\n    scheduled = false;\n    setError(err = undefined);\n    const lookup = dynamic ? dynamic() : source;\n    loadedUnderTransition = Transition && Transition.running;\n    if (lookup == null || lookup === false) {\n      loadEnd(pr, untrack(value));\n      return;\n    }\n    if (Transition && pr) Transition.promises.delete(pr);\n    const p = initP || untrack(() => fetcher(lookup, {\n      value: value(),\n      refetching\n    }));\n    if (typeof p !== \"object\" || !(\"then\" in p)) {\n      loadEnd(pr, p);\n      return p;\n    }\n    pr = p;\n    scheduled = true;\n    queueMicrotask(() => scheduled = false);\n    batch(() => {\n      setLoading(true);\n      trigger();\n    });\n    return p.then(v => loadEnd(p, v, undefined, lookup), e => loadEnd(p, e, e));\n  }\n  Object.defineProperties(read, {\n    loading: {\n      get() {\n        return loading();\n      }\n    },\n    error: {\n      get() {\n        return error();\n      }\n    },\n    latest: {\n      get() {\n        if (!resolved) return read();\n        if (err) throw err;\n        return value();\n      }\n    }\n  });\n  if (dynamic) createComputed(() => load(false));else load(false);\n  return [read, {\n    refetch: load,\n    mutate: setValue\n  }];\n}\nfunction createDeferred(source, options) {\n  let t,\n      timeout = options ? options.timeoutMs : undefined;\n  const node = createComputation(() => {\n    if (!t || !t.fn) t = requestCallback(() => setDeferred(() => node.value), timeout !== undefined ? {\n      timeout\n    } : undefined);\n    return source();\n  }, undefined, true);\n  const [deferred, setDeferred] = createSignal(node.value, options);\n  updateComputation(node);\n  setDeferred(() => node.value);\n  return deferred;\n}\nfunction createSelector(source, fn = equalFn, options) {\n  const subs = new Map();\n  const node = createComputation(p => {\n    const v = source();\n    for (const key of subs.keys()) if (fn(key, v) !== fn(key, p)) {\n      const l = subs.get(key);\n      for (const c of l.values()) {\n        c.state = STALE;\n        if (c.pure) Updates.push(c);else Effects.push(c);\n      }\n    }\n    return v;\n  }, undefined, true, STALE);\n  updateComputation(node);\n  return key => {\n    let listener;\n    if (listener = Listener) {\n      let l;\n      if (l = subs.get(key)) l.add(listener);else subs.set(key, l = new Set([listener]));\n      onCleanup(() => {\n        l.delete(listener);\n        !l.size && subs.delete(key);\n      });\n    }\n    return fn(key, Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value);\n  };\n}\nfunction batch(fn) {\n  if (Pending) return fn();\n  let result;\n  const q = Pending = [];\n  try {\n    result = fn();\n  } finally {\n    Pending = null;\n  }\n  runUpdates(() => {\n    for (let i = 0; i < q.length; i += 1) {\n      const data = q[i];\n      if (data.pending !== NOTPENDING) {\n        const pending = data.pending;\n        data.pending = NOTPENDING;\n        writeSignal(data, pending);\n      }\n    }\n  }, false);\n  return result;\n}\nfunction untrack(fn) {\n  let result,\n      listener = Listener;\n  Listener = null;\n  result = fn();\n  Listener = listener;\n  return result;\n}\nfunction on(deps, fn, options) {\n  const isArray = Array.isArray(deps);\n  let prevInput;\n  let defer = options && options.defer;\n  return prevValue => {\n    let input;\n    if (isArray) {\n      input = Array(deps.length);\n      for (let i = 0; i < deps.length; i++) input[i] = deps[i]();\n    } else input = deps();\n    if (defer) {\n      defer = false;\n      return undefined;\n    }\n    const result = untrack(() => fn(input, prevInput, prevValue));\n    prevInput = input;\n    return result;\n  };\n}\nfunction onMount(fn) {\n  createEffect(() => untrack(fn));\n}\nfunction onCleanup(fn) {\n  if (Owner === null) ;else if (Owner.cleanups === null) Owner.cleanups = [fn];else Owner.cleanups.push(fn);\n  return fn;\n}\nfunction onError(fn) {\n  ERROR || (ERROR = Symbol(\"error\"));\n  if (Owner === null) ;else if (Owner.context === null) Owner.context = {\n    [ERROR]: [fn]\n  };else if (!Owner.context[ERROR]) Owner.context[ERROR] = [fn];else Owner.context[ERROR].push(fn);\n}\nfunction getListener() {\n  return Listener;\n}\nfunction getOwner() {\n  return Owner;\n}\nfunction runWithOwner(o, fn) {\n  const prev = Owner;\n  Owner = o;\n  try {\n    return runUpdates(fn, true);\n  } finally {\n    Owner = prev;\n  }\n}\nfunction enableScheduling(scheduler = requestCallback) {\n  Scheduler = scheduler;\n}\nfunction startTransition(fn) {\n  if (Transition && Transition.running) {\n    fn();\n    return Transition.done;\n  }\n  const l = Listener;\n  const o = Owner;\n  return Promise.resolve().then(() => {\n    Listener = l;\n    Owner = o;\n    let t;\n    if (Scheduler || SuspenseContext) {\n      t = Transition || (Transition = {\n        sources: new Set(),\n        effects: [],\n        promises: new Set(),\n        disposed: new Set(),\n        queue: new Set(),\n        running: true\n      });\n      t.done || (t.done = new Promise(res => t.resolve = res));\n      t.running = true;\n    }\n    batch(fn);\n    Listener = Owner = null;\n    return t ? t.done : undefined;\n  });\n}\nfunction useTransition() {\n  return [transPending, startTransition];\n}\nfunction resumeEffects(e) {\n  Effects.push.apply(Effects, e);\n  e.length = 0;\n}\nfunction createContext(defaultValue) {\n  const id = Symbol(\"context\");\n  return {\n    id,\n    Provider: createProvider(id),\n    defaultValue\n  };\n}\nfunction useContext(context) {\n  let ctx;\n  return (ctx = lookup(Owner, context.id)) !== undefined ? ctx : context.defaultValue;\n}\nfunction children(fn) {\n  const children = createMemo(fn);\n  return createMemo(() => resolveChildren(children()));\n}\nlet SuspenseContext;\nfunction getSuspenseContext() {\n  return SuspenseContext || (SuspenseContext = createContext({}));\n}\nfunction enableExternalSource(factory) {\n  if (ExternalSourceFactory) {\n    const oldFactory = ExternalSourceFactory;\n    ExternalSourceFactory = (fn, trigger) => {\n      const oldSource = oldFactory(fn, trigger);\n      const source = factory(x => oldSource.track(x), trigger);\n      return {\n        track: x => source.track(x),\n        dispose() {\n          source.dispose();\n          oldSource.dispose();\n        }\n      };\n    };\n  } else {\n    ExternalSourceFactory = factory;\n  }\n}\nfunction readSignal() {\n  const runningTransition = Transition && Transition.running;\n  if (this.sources && (!runningTransition && this.state || runningTransition && this.tState)) {\n    const updates = Updates;\n    Updates = null;\n    !runningTransition && this.state === STALE || runningTransition && this.tState === STALE ? updateComputation(this) : lookUpstream(this);\n    Updates = updates;\n  }\n  if (Listener) {\n    const sSlot = this.observers ? this.observers.length : 0;\n    if (!Listener.sources) {\n      Listener.sources = [this];\n      Listener.sourceSlots = [sSlot];\n    } else {\n      Listener.sources.push(this);\n      Listener.sourceSlots.push(sSlot);\n    }\n    if (!this.observers) {\n      this.observers = [Listener];\n      this.observerSlots = [Listener.sources.length - 1];\n    } else {\n      this.observers.push(Listener);\n      this.observerSlots.push(Listener.sources.length - 1);\n    }\n  }\n  if (runningTransition && Transition.sources.has(this)) return this.tValue;\n  return this.value;\n}\nfunction writeSignal(node, value, isComp) {\n  if (Pending) {\n    if (node.pending === NOTPENDING) Pending.push(node);\n    node.pending = value;\n    return value;\n  }\n  if (node.comparator) {\n    if (Transition && Transition.running && Transition.sources.has(node)) {\n      if (node.comparator(node.tValue, value)) return value;\n    } else if (node.comparator(node.value, value)) return value;\n  }\n  let TransitionRunning = false;\n  if (Transition) {\n    TransitionRunning = Transition.running;\n    if (TransitionRunning || !isComp && Transition.sources.has(node)) {\n      Transition.sources.add(node);\n      node.tValue = value;\n    }\n    if (!TransitionRunning) node.value = value;\n  } else node.value = value;\n  if (node.observers && node.observers.length) {\n    runUpdates(() => {\n      for (let i = 0; i < node.observers.length; i += 1) {\n        const o = node.observers[i];\n        if (TransitionRunning && Transition.disposed.has(o)) continue;\n        if (TransitionRunning && !o.tState || !TransitionRunning && !o.state) {\n          if (o.pure) Updates.push(o);else Effects.push(o);\n          if (o.observers) markDownstream(o);\n        }\n        if (TransitionRunning) o.tState = STALE;else o.state = STALE;\n      }\n      if (Updates.length > 10e5) {\n        Updates = [];\n        if (false) ;\n        throw new Error();\n      }\n    }, false);\n  }\n  return value;\n}\nfunction updateComputation(node) {\n  if (!node.fn) return;\n  cleanNode(node);\n  const owner = Owner,\n        listener = Listener,\n        time = ExecCount;\n  Listener = Owner = node;\n  runComputation(node, Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value, time);\n  if (Transition && !Transition.running && Transition.sources.has(node)) {\n    queueMicrotask(() => {\n      runUpdates(() => {\n        Transition && (Transition.running = true);\n        runComputation(node, node.tValue, time);\n      }, false);\n    });\n  }\n  Listener = listener;\n  Owner = owner;\n}\nfunction runComputation(node, value, time) {\n  let nextValue;\n  try {\n    nextValue = node.fn(value);\n  } catch (err) {\n    handleError(err);\n  }\n  if (!node.updatedAt || node.updatedAt <= time) {\n    if (node.observers && node.observers.length) {\n      writeSignal(node, nextValue, true);\n    } else if (Transition && Transition.running && node.pure) {\n      Transition.sources.add(node);\n      node.tValue = nextValue;\n    } else node.value = nextValue;\n    node.updatedAt = time;\n  }\n}\nfunction createComputation(fn, init, pure, state = STALE, options) {\n  const c = {\n    fn,\n    state: state,\n    updatedAt: null,\n    owned: null,\n    sources: null,\n    sourceSlots: null,\n    cleanups: null,\n    value: init,\n    owner: Owner,\n    context: null,\n    pure\n  };\n  if (Transition && Transition.running) {\n    c.state = 0;\n    c.tState = state;\n  }\n  if (Owner === null) ;else if (Owner !== UNOWNED) {\n    if (Transition && Transition.running && Owner.pure) {\n      if (!Owner.tOwned) Owner.tOwned = [c];else Owner.tOwned.push(c);\n    } else {\n      if (!Owner.owned) Owner.owned = [c];else Owner.owned.push(c);\n    }\n  }\n  if (ExternalSourceFactory) {\n    const [track, trigger] = createSignal(undefined, {\n      equals: false\n    });\n    const ordinary = ExternalSourceFactory(c.fn, trigger);\n    onCleanup(() => ordinary.dispose());\n    const triggerInTransition = () => startTransition(trigger).then(() => inTransition.dispose());\n    const inTransition = ExternalSourceFactory(c.fn, triggerInTransition);\n    c.fn = x => {\n      track();\n      return Transition && Transition.running ? inTransition.track(x) : ordinary.track(x);\n    };\n  }\n  return c;\n}\nfunction runTop(node) {\n  const runningTransition = Transition && Transition.running;\n  if (!runningTransition && node.state === 0 || runningTransition && node.tState === 0) return;\n  if (!runningTransition && node.state === PENDING || runningTransition && node.tState === PENDING) return lookUpstream(node);\n  if (node.suspense && untrack(node.suspense.inFallback)) return node.suspense.effects.push(node);\n  const ancestors = [node];\n  while ((node = node.owner) && (!node.updatedAt || node.updatedAt < ExecCount)) {\n    if (runningTransition && Transition.disposed.has(node)) return;\n    if (!runningTransition && node.state || runningTransition && node.tState) ancestors.push(node);\n  }\n  for (let i = ancestors.length - 1; i >= 0; i--) {\n    node = ancestors[i];\n    if (runningTransition) {\n      let top = node,\n          prev = ancestors[i + 1];\n      while ((top = top.owner) && top !== prev) {\n        if (Transition.disposed.has(top)) return;\n      }\n    }\n    if (!runningTransition && node.state === STALE || runningTransition && node.tState === STALE) {\n      updateComputation(node);\n    } else if (!runningTransition && node.state === PENDING || runningTransition && node.tState === PENDING) {\n      const updates = Updates;\n      Updates = null;\n      lookUpstream(node, ancestors[0]);\n      Updates = updates;\n    }\n  }\n}\nfunction runUpdates(fn, init) {\n  if (Updates) return fn();\n  let wait = false;\n  if (!init) Updates = [];\n  if (Effects) wait = true;else Effects = [];\n  ExecCount++;\n  try {\n    const res = fn();\n    completeUpdates(wait);\n    return res;\n  } catch (err) {\n    if (!Updates) Effects = null;\n    handleError(err);\n  }\n}\nfunction completeUpdates(wait) {\n  if (Updates) {\n    if (Scheduler && Transition && Transition.running) scheduleQueue(Updates);else runQueue(Updates);\n    Updates = null;\n  }\n  if (wait) return;\n  let res;\n  if (Transition && Transition.running) {\n    if (Transition.promises.size || Transition.queue.size) {\n      Transition.running = false;\n      Transition.effects.push.apply(Transition.effects, Effects);\n      Effects = null;\n      setTransPending(true);\n      return;\n    }\n    const sources = Transition.sources;\n    const disposed = Transition.disposed;\n    res = Transition.resolve;\n    for (const e of Effects) {\n      \"tState\" in e && (e.state = e.tState);\n      delete e.tState;\n    }\n    Transition = null;\n    batch(() => {\n      for (const d of disposed) cleanNode(d);\n      for (const v of sources) {\n        v.value = v.tValue;\n        if (v.owned) {\n          for (let i = 0, len = v.owned.length; i < len; i++) cleanNode(v.owned[i]);\n        }\n        if (v.tOwned) v.owned = v.tOwned;\n        delete v.tValue;\n        delete v.tOwned;\n        v.tState = 0;\n      }\n      setTransPending(false);\n    });\n  }\n  if (Effects.length) batch(() => {\n    runEffects(Effects);\n    Effects = null;\n  });else {\n    Effects = null;\n  }\n  if (res) res();\n}\nfunction runQueue(queue) {\n  for (let i = 0; i < queue.length; i++) runTop(queue[i]);\n}\nfunction scheduleQueue(queue) {\n  for (let i = 0; i < queue.length; i++) {\n    const item = queue[i];\n    const tasks = Transition.queue;\n    if (!tasks.has(item)) {\n      tasks.add(item);\n      Scheduler(() => {\n        tasks.delete(item);\n        runUpdates(() => {\n          Transition.running = true;\n          runTop(item);\n          if (!tasks.size) {\n            Effects.push.apply(Effects, Transition.effects);\n            Transition.effects = [];\n          }\n        }, false);\n        Transition && (Transition.running = false);\n      });\n    }\n  }\n}\nfunction runUserEffects(queue) {\n  let i,\n      userLength = 0;\n  for (i = 0; i < queue.length; i++) {\n    const e = queue[i];\n    if (!e.user) runTop(e);else queue[userLength++] = e;\n  }\n  if (sharedConfig.context) setHydrateContext();\n  const resume = queue.length;\n  for (i = 0; i < userLength; i++) runTop(queue[i]);\n  for (i = resume; i < queue.length; i++) runTop(queue[i]);\n}\nfunction lookUpstream(node, ignore) {\n  const runningTransition = Transition && Transition.running;\n  if (runningTransition) node.tState = 0;else node.state = 0;\n  for (let i = 0; i < node.sources.length; i += 1) {\n    const source = node.sources[i];\n    if (source.sources) {\n      if (!runningTransition && source.state === STALE || runningTransition && source.tState === STALE) {\n        if (source !== ignore) runTop(source);\n      } else if (!runningTransition && source.state === PENDING || runningTransition && source.tState === PENDING) lookUpstream(source, ignore);\n    }\n  }\n}\nfunction markDownstream(node) {\n  const runningTransition = Transition && Transition.running;\n  for (let i = 0; i < node.observers.length; i += 1) {\n    const o = node.observers[i];\n    if (!runningTransition && !o.state || runningTransition && !o.tState) {\n      if (runningTransition) o.tState = PENDING;else o.state = PENDING;\n      if (o.pure) Updates.push(o);else Effects.push(o);\n      o.observers && markDownstream(o);\n    }\n  }\n}\nfunction cleanNode(node) {\n  let i;\n  if (node.sources) {\n    while (node.sources.length) {\n      const source = node.sources.pop(),\n            index = node.sourceSlots.pop(),\n            obs = source.observers;\n      if (obs && obs.length) {\n        const n = obs.pop(),\n              s = source.observerSlots.pop();\n        if (index < obs.length) {\n          n.sourceSlots[s] = index;\n          obs[index] = n;\n          source.observerSlots[index] = s;\n        }\n      }\n    }\n  }\n  if (Transition && Transition.running && node.pure) {\n    if (node.tOwned) {\n      for (i = 0; i < node.tOwned.length; i++) cleanNode(node.tOwned[i]);\n      delete node.tOwned;\n    }\n    reset(node, true);\n  } else if (node.owned) {\n    for (i = 0; i < node.owned.length; i++) cleanNode(node.owned[i]);\n    node.owned = null;\n  }\n  if (node.cleanups) {\n    for (i = 0; i < node.cleanups.length; i++) node.cleanups[i]();\n    node.cleanups = null;\n  }\n  if (Transition && Transition.running) node.tState = 0;else node.state = 0;\n  node.context = null;\n}\nfunction reset(node, top) {\n  if (!top) {\n    node.tState = 0;\n    Transition.disposed.add(node);\n  }\n  if (node.owned) {\n    for (let i = 0; i < node.owned.length; i++) reset(node.owned[i]);\n  }\n}\nfunction handleError(err) {\n  const fns = ERROR && lookup(Owner, ERROR);\n  if (!fns) throw err;\n  for (const f of fns) f(err);\n}\nfunction lookup(owner, key) {\n  return owner ? owner.context && owner.context[key] !== undefined ? owner.context[key] : lookup(owner.owner, key) : undefined;\n}\nfunction resolveChildren(children) {\n  if (typeof children === \"function\" && !children.length) return resolveChildren(children());\n  if (Array.isArray(children)) {\n    const results = [];\n    for (let i = 0; i < children.length; i++) {\n      const result = resolveChildren(children[i]);\n      Array.isArray(result) ? results.push.apply(results, result) : results.push(result);\n    }\n    return results;\n  }\n  return children;\n}\nfunction createProvider(id) {\n  return function provider(props) {\n    let res;\n    createComputed(() => res = untrack(() => {\n      Owner.context = {\n        [id]: props.value\n      };\n      return children(() => props.children);\n    }));\n    return res;\n  };\n}\n\nfunction observable(input) {\n  return {\n    subscribe(observer) {\n      if (!(observer instanceof Object) || observer == null) {\n        throw new TypeError(\"Expected the observer to be an object.\");\n      }\n      const handler = typeof observer === 'function' ? observer : observer.next && observer.next.bind(observer);\n      if (!handler) {\n        return {\n          unsubscribe() {}\n        };\n      }\n      const dispose = createRoot(disposer => {\n        createComputed(() => {\n          const v = input();\n          untrack(() => handler(v));\n        });\n        return disposer;\n      });\n      if (getOwner()) onCleanup(dispose);\n      return {\n        unsubscribe() {\n          dispose();\n        }\n      };\n    },\n    [Symbol.observable || \"@@observable\"]() {\n      return this;\n    }\n  };\n}\nfunction from(producer) {\n  const [s, set] = createSignal(undefined, {\n    equals: false\n  });\n  if (\"subscribe\" in producer) {\n    const unsub = producer.subscribe(v => set(() => v));\n    onCleanup(() => \"unsubscribe\" in unsub ? unsub.unsubscribe() : unsub());\n  } else {\n    const clean = producer(set);\n    onCleanup(clean);\n  }\n  return s;\n}\n\nconst FALLBACK = Symbol(\"fallback\");\nfunction dispose(d) {\n  for (let i = 0; i < d.length; i++) d[i]();\n}\nfunction mapArray(list, mapFn, options = {}) {\n  let items = [],\n      mapped = [],\n      disposers = [],\n      len = 0,\n      indexes = mapFn.length > 1 ? [] : null;\n  onCleanup(() => dispose(disposers));\n  return () => {\n    let newItems = list() || [],\n        i,\n        j;\n    newItems[$TRACK];\n    return untrack(() => {\n      let newLen = newItems.length,\n          newIndices,\n          newIndicesNext,\n          temp,\n          tempdisposers,\n          tempIndexes,\n          start,\n          end,\n          newEnd,\n          item;\n      if (newLen === 0) {\n        if (len !== 0) {\n          dispose(disposers);\n          disposers = [];\n          items = [];\n          mapped = [];\n          len = 0;\n          indexes && (indexes = []);\n        }\n        if (options.fallback) {\n          items = [FALLBACK];\n          mapped[0] = createRoot(disposer => {\n            disposers[0] = disposer;\n            return options.fallback();\n          });\n          len = 1;\n        }\n      }\n      else if (len === 0) {\n        mapped = new Array(newLen);\n        for (j = 0; j < newLen; j++) {\n          items[j] = newItems[j];\n          mapped[j] = createRoot(mapper);\n        }\n        len = newLen;\n      } else {\n        temp = new Array(newLen);\n        tempdisposers = new Array(newLen);\n        indexes && (tempIndexes = new Array(newLen));\n        for (start = 0, end = Math.min(len, newLen); start < end && items[start] === newItems[start]; start++);\n        for (end = len - 1, newEnd = newLen - 1; end >= start && newEnd >= start && items[end] === newItems[newEnd]; end--, newEnd--) {\n          temp[newEnd] = mapped[end];\n          tempdisposers[newEnd] = disposers[end];\n          indexes && (tempIndexes[newEnd] = indexes[end]);\n        }\n        newIndices = new Map();\n        newIndicesNext = new Array(newEnd + 1);\n        for (j = newEnd; j >= start; j--) {\n          item = newItems[j];\n          i = newIndices.get(item);\n          newIndicesNext[j] = i === undefined ? -1 : i;\n          newIndices.set(item, j);\n        }\n        for (i = start; i <= end; i++) {\n          item = items[i];\n          j = newIndices.get(item);\n          if (j !== undefined && j !== -1) {\n            temp[j] = mapped[i];\n            tempdisposers[j] = disposers[i];\n            indexes && (tempIndexes[j] = indexes[i]);\n            j = newIndicesNext[j];\n            newIndices.set(item, j);\n          } else disposers[i]();\n        }\n        for (j = start; j < newLen; j++) {\n          if (j in temp) {\n            mapped[j] = temp[j];\n            disposers[j] = tempdisposers[j];\n            if (indexes) {\n              indexes[j] = tempIndexes[j];\n              indexes[j](j);\n            }\n          } else mapped[j] = createRoot(mapper);\n        }\n        mapped = mapped.slice(0, len = newLen);\n        items = newItems.slice(0);\n      }\n      return mapped;\n    });\n    function mapper(disposer) {\n      disposers[j] = disposer;\n      if (indexes) {\n        const [s, set] = createSignal(j);\n        indexes[j] = set;\n        return mapFn(newItems[j], s);\n      }\n      return mapFn(newItems[j]);\n    }\n  };\n}\nfunction indexArray(list, mapFn, options = {}) {\n  let items = [],\n      mapped = [],\n      disposers = [],\n      signals = [],\n      len = 0,\n      i;\n  onCleanup(() => dispose(disposers));\n  return () => {\n    const newItems = list() || [];\n    newItems[$TRACK];\n    return untrack(() => {\n      if (newItems.length === 0) {\n        if (len !== 0) {\n          dispose(disposers);\n          disposers = [];\n          items = [];\n          mapped = [];\n          len = 0;\n          signals = [];\n        }\n        if (options.fallback) {\n          items = [FALLBACK];\n          mapped[0] = createRoot(disposer => {\n            disposers[0] = disposer;\n            return options.fallback();\n          });\n          len = 1;\n        }\n        return mapped;\n      }\n      if (items[0] === FALLBACK) {\n        disposers[0]();\n        disposers = [];\n        items = [];\n        mapped = [];\n        len = 0;\n      }\n      for (i = 0; i < newItems.length; i++) {\n        if (i < items.length && items[i] !== newItems[i]) {\n          signals[i](() => newItems[i]);\n        } else if (i >= items.length) {\n          mapped[i] = createRoot(mapper);\n        }\n      }\n      for (; i < items.length; i++) {\n        disposers[i]();\n      }\n      len = signals.length = disposers.length = newItems.length;\n      items = newItems.slice(0);\n      return mapped = mapped.slice(0, len);\n    });\n    function mapper(disposer) {\n      disposers[i] = disposer;\n      const [s, set] = createSignal(newItems[i]);\n      signals[i] = set;\n      return mapFn(s, i);\n    }\n  };\n}\n\nlet hydrationEnabled = false;\nfunction enableHydration() {\n  hydrationEnabled = true;\n}\nfunction createComponent(Comp, props) {\n  if (hydrationEnabled) {\n    if (sharedConfig.context) {\n      const c = sharedConfig.context;\n      setHydrateContext(nextHydrateContext());\n      const r = untrack(() => Comp(props || {}));\n      setHydrateContext(c);\n      return r;\n    }\n  }\n  return untrack(() => Comp(props || {}));\n}\nfunction trueFn() {\n  return true;\n}\nconst propTraps = {\n  get(_, property, receiver) {\n    if (property === $PROXY) return receiver;\n    return _.get(property);\n  },\n  has(_, property) {\n    return _.has(property);\n  },\n  set: trueFn,\n  deleteProperty: trueFn,\n  getOwnPropertyDescriptor(_, property) {\n    return {\n      configurable: true,\n      enumerable: true,\n      get() {\n        return _.get(property);\n      },\n      set: trueFn,\n      deleteProperty: trueFn\n    };\n  },\n  ownKeys(_) {\n    return _.keys();\n  }\n};\nfunction resolveSource(s) {\n  return (s = typeof s === \"function\" ? s() : s) == null ? {} : s;\n}\nfunction mergeProps(...sources) {\n  return new Proxy({\n    get(property) {\n      for (let i = sources.length - 1; i >= 0; i--) {\n        const v = resolveSource(sources[i])[property];\n        if (v !== undefined) return v;\n      }\n    },\n    has(property) {\n      for (let i = sources.length - 1; i >= 0; i--) {\n        if (property in resolveSource(sources[i])) return true;\n      }\n      return false;\n    },\n    keys() {\n      const keys = [];\n      for (let i = 0; i < sources.length; i++) keys.push(...Object.keys(resolveSource(sources[i])));\n      return [...new Set(keys)];\n    }\n  }, propTraps);\n}\nfunction splitProps(props, ...keys) {\n  const blocked = new Set(keys.flat());\n  const descriptors = Object.getOwnPropertyDescriptors(props);\n  const res = keys.map(k => {\n    const clone = {};\n    for (let i = 0; i < k.length; i++) {\n      const key = k[i];\n      Object.defineProperty(clone, key, descriptors[key] ? descriptors[key] : {\n        get() {\n          return props[key];\n        },\n        set() {\n          return true;\n        }\n      });\n    }\n    return clone;\n  });\n  res.push(new Proxy({\n    get(property) {\n      return blocked.has(property) ? undefined : props[property];\n    },\n    has(property) {\n      return blocked.has(property) ? false : property in props;\n    },\n    keys() {\n      return Object.keys(props).filter(k => !blocked.has(k));\n    }\n  }, propTraps));\n  return res;\n}\nfunction lazy(fn) {\n  let comp;\n  let p;\n  const wrap = props => {\n    const ctx = sharedConfig.context;\n    if (ctx) {\n      const [s, set] = createSignal();\n      (p || (p = fn())).then(mod => {\n        setHydrateContext(ctx);\n        set(() => mod.default);\n        setHydrateContext();\n      });\n      comp = s;\n    } else if (!comp) {\n      const [s] = createResource(() => (p || (p = fn())).then(mod => mod.default));\n      comp = s;\n    } else {\n      const c = comp();\n      if (c) return c(props);\n    }\n    let Comp;\n    return createMemo(() => (Comp = comp()) && untrack(() => {\n      if (!ctx) return Comp(props);\n      const c = sharedConfig.context;\n      setHydrateContext(ctx);\n      const r = Comp(props);\n      setHydrateContext(c);\n      return r;\n    }));\n  };\n  wrap.preload = () => p || ((p = fn()).then(mod => comp = () => mod.default), p);\n  return wrap;\n}\nlet counter = 0;\nfunction createUniqueId() {\n  const ctx = sharedConfig.context;\n  return ctx ? `${ctx.id}${ctx.count++}` : `cl-${counter++}`;\n}\n\nfunction For(props) {\n  const fallback = \"fallback\" in props && {\n    fallback: () => props.fallback\n  };\n  return createMemo(mapArray(() => props.each, props.children, fallback ? fallback : undefined));\n}\nfunction Index(props) {\n  const fallback = \"fallback\" in props && {\n    fallback: () => props.fallback\n  };\n  return createMemo(indexArray(() => props.each, props.children, fallback ? fallback : undefined));\n}\nfunction Show(props) {\n  let strictEqual = false;\n  const condition = createMemo(() => props.when, undefined, {\n    equals: (a, b) => strictEqual ? a === b : !a === !b\n  });\n  return createMemo(() => {\n    const c = condition();\n    if (c) {\n      const child = props.children;\n      return (strictEqual = typeof child === \"function\" && child.length > 0) ? untrack(() => child(c)) : child;\n    }\n    return props.fallback;\n  });\n}\nfunction Switch(props) {\n  let strictEqual = false;\n  const conditions = children(() => props.children),\n        evalConditions = createMemo(() => {\n    let conds = conditions();\n    if (!Array.isArray(conds)) conds = [conds];\n    for (let i = 0; i < conds.length; i++) {\n      const c = conds[i].when;\n      if (c) return [i, c, conds[i]];\n    }\n    return [-1];\n  }, undefined, {\n    equals: (a, b) => a[0] === b[0] && (strictEqual ? a[1] === b[1] : !a[1] === !b[1]) && a[2] === b[2]\n  });\n  return createMemo(() => {\n    const [index, when, cond] = evalConditions();\n    if (index < 0) return props.fallback;\n    const c = cond.children;\n    return (strictEqual = typeof c === \"function\" && c.length > 0) ? untrack(() => c(when)) : c;\n  });\n}\nfunction Match(props) {\n  return props;\n}\nlet Errors;\nconst NoErrors = {};\nfunction resetErrorBoundaries() {\n  Errors && [...Errors].forEach(fn => fn(NoErrors));\n}\nfunction ErrorBoundary(props) {\n  let err = NoErrors;\n  if (sharedConfig.context && sharedConfig.load) {\n    err = sharedConfig.load(sharedConfig.context.id + sharedConfig.context.count) || NoErrors;\n  }\n  const [errored, setErrored] = createSignal(err);\n  Errors || (Errors = new Set());\n  Errors.add(setErrored);\n  onCleanup(() => Errors.delete(setErrored));\n  return createMemo(() => {\n    let e;\n    if ((e = errored()) !== NoErrors) {\n      const f = props.fallback;\n      return typeof f === \"function\" && f.length ? untrack(() => f(e, () => setErrored(NoErrors))) : f;\n    }\n    onError(setErrored);\n    return props.children;\n  });\n}\n\nconst SuspenseListContext = createContext();\nfunction SuspenseList(props) {\n  let suspenseSetter, showContent, showFallback;\n  const listContext = useContext(SuspenseListContext);\n  if (listContext) {\n    const [inFallback, setFallback] = createSignal(false);\n    suspenseSetter = setFallback;\n    [showContent, showFallback] = listContext.register(inFallback);\n  }\n  const [registry, setRegistry] = createSignal([]),\n        comp = createComponent(SuspenseListContext.Provider, {\n    value: {\n      register: inFallback => {\n        const [showingContent, showContent] = createSignal(false),\n              [showingFallback, showFallback] = createSignal(false);\n        setRegistry(registry => [...registry, {\n          inFallback,\n          showContent,\n          showFallback\n        }]);\n        return [showingContent, showingFallback];\n      }\n    },\n    get children() {\n      return props.children;\n    }\n  });\n  createComputed(() => {\n    const reveal = props.revealOrder,\n          tail = props.tail,\n          visibleContent = showContent ? showContent() : true,\n          visibleFallback = showFallback ? showFallback() : true,\n          reg = registry(),\n          reverse = reveal === \"backwards\";\n    if (reveal === \"together\") {\n      const all = reg.every(i => !i.inFallback());\n      suspenseSetter && suspenseSetter(!all);\n      reg.forEach(i => {\n        i.showContent(all && visibleContent);\n        i.showFallback(visibleFallback);\n      });\n      return;\n    }\n    let stop = false;\n    for (let i = 0, len = reg.length; i < len; i++) {\n      const n = reverse ? len - i - 1 : i,\n            s = reg[n].inFallback();\n      if (!stop && !s) {\n        reg[n].showContent(visibleContent);\n        reg[n].showFallback(visibleFallback);\n      } else {\n        const next = !stop;\n        if (next && suspenseSetter) suspenseSetter(true);\n        if (!tail || next && tail === \"collapsed\") {\n          reg[n].showFallback(visibleFallback);\n        } else reg[n].showFallback(false);\n        stop = true;\n        reg[n].showContent(next);\n      }\n    }\n    if (!stop && suspenseSetter) suspenseSetter(false);\n  });\n  return comp;\n}\nfunction Suspense(props) {\n  let counter = 0,\n      showContent,\n      showFallback,\n      ctx,\n      p,\n      flicker,\n      error;\n  const [inFallback, setFallback] = createSignal(false),\n        SuspenseContext = getSuspenseContext(),\n        store = {\n    increment: () => {\n      if (++counter === 1) setFallback(true);\n    },\n    decrement: () => {\n      if (--counter === 0) setFallback(false);\n    },\n    inFallback,\n    effects: [],\n    resolved: false\n  },\n        owner = getOwner();\n  if (sharedConfig.context && sharedConfig.load) {\n    const key = sharedConfig.context.id + sharedConfig.context.count;\n    p = sharedConfig.load(key);\n    if (p) {\n      if (typeof p !== \"object\" || !(\"then\" in p)) p = Promise.resolve(p);\n      const [s, set] = createSignal(undefined, {\n        equals: false\n      });\n      flicker = s;\n      p.then(err => {\n        if ((error = err) || sharedConfig.done) return set();\n        sharedConfig.gather(key);\n        setHydrateContext(ctx);\n        set();\n        setHydrateContext();\n      });\n    } else if (p === null) sharedConfig.gather(key);\n  }\n  const listContext = useContext(SuspenseListContext);\n  if (listContext) [showContent, showFallback] = listContext.register(store.inFallback);\n  let dispose;\n  onCleanup(() => dispose && dispose());\n  return createComponent(SuspenseContext.Provider, {\n    value: store,\n    get children() {\n      return createMemo(() => {\n        if (error) throw error;\n        ctx = sharedConfig.context;\n        if (flicker) {\n          flicker();\n          return flicker = undefined;\n        }\n        if (ctx && p === undefined) setHydrateContext();\n        const rendered = createMemo(() => props.children);\n        return createMemo(() => {\n          const inFallback = store.inFallback(),\n                visibleContent = showContent ? showContent() : true,\n                visibleFallback = showFallback ? showFallback() : true;\n          dispose && dispose();\n          if ((!inFallback || p !== undefined) && visibleContent) {\n            store.resolved = true;\n            ctx = p = undefined;\n            resumeEffects(store.effects);\n            return rendered();\n          }\n          if (!visibleFallback) return;\n          return createRoot(disposer => {\n            dispose = disposer;\n            if (ctx) {\n              setHydrateContext({\n                id: ctx.id + \"f\",\n                count: 0\n              });\n              ctx = undefined;\n            }\n            return props.fallback;\n          }, owner);\n        });\n      });\n    }\n  });\n}\n\nlet DEV;\n\nexport { $DEVCOMP, $PROXY, $TRACK, DEV, ErrorBoundary, For, Index, Match, Show, Suspense, SuspenseList, Switch, batch, cancelCallback, children, createComponent, createComputed, createContext, createDeferred, createEffect, createMemo, createReaction, createRenderEffect, createResource, createRoot, createSelector, createSignal, createUniqueId, enableExternalSource, enableHydration, enableScheduling, equalFn, from, getListener, getOwner, indexArray, lazy, mapArray, mergeProps, observable, on, onCleanup, onError, onMount, requestCallback, resetErrorBoundaries, runWithOwner, sharedConfig, splitProps, startTransition, untrack, useContext, useTransition };\n","import { $PROXY, $TRACK, getListener, batch, createSignal } from 'solid-js';\n\nconst $RAW = Symbol(\"store-raw\"),\n      $NODE = Symbol(\"store-node\"),\n      $NAME = Symbol(\"store-name\");\nfunction wrap$1(value, name) {\n  let p = value[$PROXY];\n  if (!p) {\n    Object.defineProperty(value, $PROXY, {\n      value: p = new Proxy(value, proxyTraps$1)\n    });\n    const keys = Object.keys(value),\n          desc = Object.getOwnPropertyDescriptors(value);\n    for (let i = 0, l = keys.length; i < l; i++) {\n      const prop = keys[i];\n      if (desc[prop].get) {\n        const get = desc[prop].get.bind(p);\n        Object.defineProperty(value, prop, {\n          get\n        });\n      }\n    }\n  }\n  return p;\n}\nfunction isWrappable(obj) {\n  let proto;\n  return obj != null && typeof obj === \"object\" && (obj[$PROXY] || !(proto = Object.getPrototypeOf(obj)) || proto === Object.prototype || Array.isArray(obj));\n}\nfunction unwrap(item, set = new Set()) {\n  let result, unwrapped, v, prop;\n  if (result = item != null && item[$RAW]) return result;\n  if (!isWrappable(item) || set.has(item)) return item;\n  if (Array.isArray(item)) {\n    if (Object.isFrozen(item)) item = item.slice(0);else set.add(item);\n    for (let i = 0, l = item.length; i < l; i++) {\n      v = item[i];\n      if ((unwrapped = unwrap(v, set)) !== v) item[i] = unwrapped;\n    }\n  } else {\n    if (Object.isFrozen(item)) item = Object.assign({}, item);else set.add(item);\n    const keys = Object.keys(item),\n          desc = Object.getOwnPropertyDescriptors(item);\n    for (let i = 0, l = keys.length; i < l; i++) {\n      prop = keys[i];\n      if (desc[prop].get) continue;\n      v = item[prop];\n      if ((unwrapped = unwrap(v, set)) !== v) item[prop] = unwrapped;\n    }\n  }\n  return item;\n}\nfunction getDataNodes(target) {\n  let nodes = target[$NODE];\n  if (!nodes) Object.defineProperty(target, $NODE, {\n    value: nodes = {}\n  });\n  return nodes;\n}\nfunction getDataNode(nodes, property, value) {\n  return nodes[property] || (nodes[property] = createDataNode(value, true));\n}\nfunction proxyDescriptor(target, property) {\n  const desc = Reflect.getOwnPropertyDescriptor(target, property);\n  if (!desc || desc.get || !desc.configurable || property === $PROXY || property === $NODE || property === $NAME) return desc;\n  delete desc.value;\n  delete desc.writable;\n  desc.get = () => target[$PROXY][property];\n  return desc;\n}\nfunction trackSelf(target) {\n  if (getListener()) {\n    const nodes = getDataNodes(target);\n    (nodes._ || (nodes._ = createDataNode()))();\n  }\n}\nfunction ownKeys(target) {\n  trackSelf(target);\n  return Reflect.ownKeys(target);\n}\nfunction createDataNode(value, equals) {\n  const [s, set] = createSignal(value, equals ? {\n    internal: true\n  } : {\n    equals: false,\n    internal: true\n  });\n  s.$ = set;\n  return s;\n}\nconst proxyTraps$1 = {\n  get(target, property, receiver) {\n    if (property === $RAW) return target;\n    if (property === $PROXY) return receiver;\n    if (property === $TRACK) return trackSelf(target);\n    const nodes = getDataNodes(target);\n    const tracked = nodes[property];\n    let value = tracked ? nodes[property]() : target[property];\n    if (property === $NODE || property === \"__proto__\") return value;\n    if (!tracked) {\n      const desc = Object.getOwnPropertyDescriptor(target, property);\n      if (getListener() && (typeof value !== \"function\" || target.hasOwnProperty(property)) && !(desc && desc.get)) value = getDataNode(nodes, property, value)();\n    }\n    return isWrappable(value) ? wrap$1(value) : value;\n  },\n  set() {\n    return true;\n  },\n  deleteProperty() {\n    return true;\n  },\n  ownKeys: ownKeys,\n  getOwnPropertyDescriptor: proxyDescriptor\n};\nfunction setProperty(state, property, value) {\n  if (state[property] === value) return;\n  const prev = state[property];\n  const len = state.length;\n  if (value === undefined) {\n    delete state[property];\n  } else state[property] = value;\n  let nodes = getDataNodes(state),\n      node;\n  if (node = getDataNode(nodes, property, prev)) node.$(() => value);\n  if (Array.isArray(state) && state.length !== len) (node = getDataNode(nodes, \"length\", len)) && node.$(state.length);\n  (node = nodes._) && node.$();\n}\nfunction mergeStoreNode(state, value) {\n  const keys = Object.keys(value);\n  for (let i = 0; i < keys.length; i += 1) {\n    const key = keys[i];\n    setProperty(state, key, value[key]);\n  }\n}\nfunction updateArray(current, next) {\n  if (typeof next === \"function\") next = next(current);\n  next = unwrap(next);\n  if (Array.isArray(next)) {\n    if (current === next) return;\n    let i = 0,\n        len = next.length;\n    for (; i < len; i++) {\n      const value = next[i];\n      if (current[i] !== value) setProperty(current, i, value);\n    }\n    setProperty(current, \"length\", len);\n  } else mergeStoreNode(current, next);\n}\nfunction updatePath(current, path, traversed = []) {\n  let part,\n      prev = current;\n  if (path.length > 1) {\n    part = path.shift();\n    const partType = typeof part,\n          isArray = Array.isArray(current);\n    if (Array.isArray(part)) {\n      for (let i = 0; i < part.length; i++) {\n        updatePath(current, [part[i]].concat(path), traversed);\n      }\n      return;\n    } else if (isArray && partType === \"function\") {\n      for (let i = 0; i < current.length; i++) {\n        if (part(current[i], i)) updatePath(current, [i].concat(path), traversed);\n      }\n      return;\n    } else if (isArray && partType === \"object\") {\n      const {\n        from = 0,\n        to = current.length - 1,\n        by = 1\n      } = part;\n      for (let i = from; i <= to; i += by) {\n        updatePath(current, [i].concat(path), traversed);\n      }\n      return;\n    } else if (path.length > 1) {\n      updatePath(current[part], path, [part].concat(traversed));\n      return;\n    }\n    prev = current[part];\n    traversed = [part].concat(traversed);\n  }\n  let value = path[0];\n  if (typeof value === \"function\") {\n    value = value(prev, traversed);\n    if (value === prev) return;\n  }\n  if (part === undefined && value == undefined) return;\n  value = unwrap(value);\n  if (part === undefined || isWrappable(prev) && isWrappable(value) && !Array.isArray(value)) {\n    mergeStoreNode(prev, value);\n  } else setProperty(current, part, value);\n}\nfunction createStore(...[store, options]) {\n  const unwrappedStore = unwrap(store || {});\n  const isArray = Array.isArray(unwrappedStore);\n  const wrappedStore = wrap$1(unwrappedStore);\n  function setStore(...args) {\n    batch(() => {\n      isArray && args.length === 1 ? updateArray(unwrappedStore, args[0]) : updatePath(unwrappedStore, args);\n    });\n  }\n  return [wrappedStore, setStore];\n}\n\nconst proxyTraps = {\n  get(target, property, receiver) {\n    if (property === $RAW) return target;\n    if (property === $PROXY) return receiver;\n    if (property === $TRACK) return trackSelf(target);\n    const nodes = getDataNodes(target);\n    const tracked = nodes[property];\n    let value = tracked ? nodes[property]() : target[property];\n    if (property === $NODE || property === \"__proto__\") return value;\n    if (!tracked) {\n      const desc = Object.getOwnPropertyDescriptor(target, property);\n      const isFunction = typeof value === \"function\";\n      if (getListener() && (!isFunction || target.hasOwnProperty(property)) && !(desc && desc.get)) value = getDataNode(nodes, property, value)();else if (value != null && isFunction && value === Array.prototype[property]) {\n        return (...args) => batch(() => Array.prototype[property].apply(receiver, args));\n      }\n    }\n    return isWrappable(value) ? wrap(value) : value;\n  },\n  set(target, property, value) {\n    batch(() => setProperty(target, property, unwrap(value)));\n    return true;\n  },\n  deleteProperty(target, property) {\n    batch(() => setProperty(target, property, undefined));\n    return true;\n  },\n  ownKeys: ownKeys,\n  getOwnPropertyDescriptor: proxyDescriptor\n};\nfunction wrap(value, name) {\n  let p = value[$PROXY];\n  if (!p) {\n    Object.defineProperty(value, $PROXY, {\n      value: p = new Proxy(value, proxyTraps)\n    });\n    const keys = Object.keys(value),\n          desc = Object.getOwnPropertyDescriptors(value);\n    for (let i = 0, l = keys.length; i < l; i++) {\n      const prop = keys[i];\n      if (desc[prop].get) {\n        const get = desc[prop].get.bind(p);\n        Object.defineProperty(value, prop, {\n          get\n        });\n      }\n      if (desc[prop].set) {\n        const og = desc[prop].set,\n              set = v => batch(() => og.call(p, v));\n        Object.defineProperty(value, prop, {\n          set\n        });\n      }\n    }\n  }\n  return p;\n}\nfunction createMutable(state, options) {\n  const unwrappedStore = unwrap(state || {});\n  const wrappedStore = wrap(unwrappedStore);\n  return wrappedStore;\n}\nfunction modifyMutable(state, modifier) {\n  batch(() => modifier(unwrap(state)));\n}\n\nconst $ROOT = Symbol(\"store-root\");\nfunction applyState(target, parent, property, merge, key) {\n  const previous = parent[property];\n  if (target === previous) return;\n  if (!isWrappable(target) || !isWrappable(previous) || key && target[key] !== previous[key]) {\n    if (target !== previous) {\n      if (property === $ROOT) return target;\n      setProperty(parent, property, target);\n    }\n    return;\n  }\n  if (Array.isArray(target)) {\n    if (target.length && previous.length && (!merge || key && target[0][key] != null)) {\n      let i, j, start, end, newEnd, item, newIndicesNext, keyVal;\n      for (start = 0, end = Math.min(previous.length, target.length); start < end && (previous[start] === target[start] || key && previous[start][key] === target[start][key]); start++) {\n        applyState(target[start], previous, start, merge, key);\n      }\n      const temp = new Array(target.length),\n            newIndices = new Map();\n      for (end = previous.length - 1, newEnd = target.length - 1; end >= start && newEnd >= start && (previous[end] === target[newEnd] || key && previous[end][key] === target[newEnd][key]); end--, newEnd--) {\n        temp[newEnd] = previous[end];\n      }\n      if (start > newEnd || start > end) {\n        for (j = start; j <= newEnd; j++) setProperty(previous, j, target[j]);\n        for (; j < target.length; j++) {\n          setProperty(previous, j, temp[j]);\n          applyState(target[j], previous, j, merge, key);\n        }\n        if (previous.length > target.length) setProperty(previous, \"length\", target.length);\n        return;\n      }\n      newIndicesNext = new Array(newEnd + 1);\n      for (j = newEnd; j >= start; j--) {\n        item = target[j];\n        keyVal = key ? item[key] : item;\n        i = newIndices.get(keyVal);\n        newIndicesNext[j] = i === undefined ? -1 : i;\n        newIndices.set(keyVal, j);\n      }\n      for (i = start; i <= end; i++) {\n        item = previous[i];\n        keyVal = key ? item[key] : item;\n        j = newIndices.get(keyVal);\n        if (j !== undefined && j !== -1) {\n          temp[j] = previous[i];\n          j = newIndicesNext[j];\n          newIndices.set(keyVal, j);\n        }\n      }\n      for (j = start; j < target.length; j++) {\n        if (j in temp) {\n          setProperty(previous, j, temp[j]);\n          applyState(target[j], previous, j, merge, key);\n        } else setProperty(previous, j, target[j]);\n      }\n    } else {\n      for (let i = 0, len = target.length; i < len; i++) {\n        applyState(target[i], previous, i, merge, key);\n      }\n    }\n    if (previous.length > target.length) setProperty(previous, \"length\", target.length);\n    return;\n  }\n  const targetKeys = Object.keys(target);\n  for (let i = 0, len = targetKeys.length; i < len; i++) {\n    applyState(target[targetKeys[i]], previous, targetKeys[i], merge, key);\n  }\n  const previousKeys = Object.keys(previous);\n  for (let i = 0, len = previousKeys.length; i < len; i++) {\n    if (target[previousKeys[i]] === undefined) setProperty(previous, previousKeys[i], undefined);\n  }\n}\nfunction reconcile(value, options = {}) {\n  const {\n    merge,\n    key = \"id\"\n  } = options,\n        v = unwrap(value);\n  return state => {\n    if (!isWrappable(state) || !isWrappable(v)) return v;\n    const res = applyState(v, {\n      [$ROOT]: state\n    }, $ROOT, merge, key);\n    return res === undefined ? state : res;\n  };\n}\nconst producers = new WeakMap();\nconst setterTraps = {\n  get(target, property) {\n    if (property === $RAW) return target;\n    const value = target[property];\n    let proxy;\n    return isWrappable(value) ? producers.get(value) || (producers.set(value, proxy = new Proxy(value, setterTraps)), proxy) : value;\n  },\n  set(target, property, value) {\n    setProperty(target, property, unwrap(value));\n    return true;\n  },\n  deleteProperty(target, property) {\n    setProperty(target, property, undefined);\n    return true;\n  }\n};\nfunction produce(fn) {\n  return state => {\n    if (isWrappable(state)) {\n      let proxy;\n      if (!(proxy = producers.get(state))) {\n        producers.set(state, proxy = new Proxy(state, setterTraps));\n      }\n      fn(proxy);\n    }\n    return state;\n  };\n}\n\nexport { $RAW, createMutable, createStore, modifyMutable, produce, reconcile, unwrap };\n","import {$TRACK} from 'solid-js'\nimport {createMutable, modifyMutable, reconcile} from 'solid-js/store'\nimport type {PossibleBehaviorInstance} from './BehaviorRegistry.js'\n\n/**\n * A map of behavior names to their defined classes.\n *\n * Reactive in Solid.js.\n */\n\nexport class BehaviorMap extends Map<string, PossibleBehaviorInstance> {\n\t#reactivityTriggerObject = createMutable<Record<string, PossibleBehaviorInstance>>({})\n\n\tfind(predicate: (name: string, behavior: PossibleBehaviorInstance) => boolean) {\n\t\tlet result: PossibleBehaviorInstance | undefined = void undefined\n\n\t\tfor (const [name, behavior] of this) {\n\t\t\tif (!predicate(name, behavior)) continue\n\t\t\tresult = behavior\n\t\t\tbreak\n\t\t}\n\n\t\treturn result\n\t}\n\n\toverride get(key: string): PossibleBehaviorInstance | undefined {\n\t\t// read, causes tracking in Solid.js effects.\n\t\tthis.#reactivityTriggerObject[key]\n\n\t\treturn super.get(key)\n\t}\n\n\toverride set(key: string, value: PossibleBehaviorInstance): this {\n\t\tqueueMicrotask(() => {\n\t\t\t// write, triggers Solid.js effects\n\t\t\tthis.#reactivityTriggerObject[key] = value\n\t\t})\n\n\t\t// TODO Remove the set() method from end users, allow the user to add\n\t\t// behaviors in a fashion similar to classList.add().\n\t\tsuper.set(key, value)\n\t\treturn this\n\t}\n\n\toverride delete(key: string): boolean {\n\t\tqueueMicrotask(() => {\n\t\t\t// write, triggers Solid.js effects\n\t\t\tdelete this.#reactivityTriggerObject[key]\n\t\t})\n\n\t\treturn super.delete(key)\n\t}\n\n\toverride clear(): void {\n\t\tqueueMicrotask(() => {\n\t\t\t// delete all properties, trigger single Solid.js effect update\n\t\t\tmodifyMutable(this.#reactivityTriggerObject, reconcile({}))\n\t\t})\n\n\t\tsuper.clear()\n\t}\n\n\toverride has(key: string): boolean {\n\t\t// read, causes tracking in Solid.js effects.\n\t\t// (TODO `in` operator not reactive yet, https://github.com/solidjs/solid/issues/1107)\n\t\t// key in this.#reactivityTriggerObject\n\t\t// Workaround, read the property\n\t\tthis.#reactivityTriggerObject[key]\n\n\t\treturn super.has(key)\n\t}\n\n\toverride entries(): IterableIterator<[string, PossibleBehaviorInstance]> {\n\t\t// track all properties in a Solid effect\n\t\t// @ts-expect-error\n\t\tthis.#reactivityTriggerObject[$TRACK]\n\n\t\treturn super.entries()\n\t}\n\n\toverride [Symbol.iterator](): IterableIterator<[string, PossibleBehaviorInstance]> {\n\t\t// track all properties in a Solid effect\n\t\t// @ts-expect-error\n\t\tthis.#reactivityTriggerObject[$TRACK]\n\n\t\treturn super[Symbol.iterator]()\n\t}\n\n\toverride forEach(\n\t\tcallbackfn: (value: PossibleBehaviorInstance, key: string, map: Map<string, PossibleBehaviorInstance>) => void,\n\t\tthisArg?: any,\n\t): void {\n\t\t// track all properties in a Solid effect\n\t\t// @ts-expect-error\n\t\tthis.#reactivityTriggerObject[$TRACK]\n\n\t\tsuper.forEach(callbackfn, thisArg)\n\t}\n\n\toverride keys(): IterableIterator<string> {\n\t\t// track all properties in a Solid effect\n\t\t// @ts-expect-error\n\t\tthis.#reactivityTriggerObject[$TRACK]\n\n\t\treturn super.keys()\n\t}\n\n\toverride get size(): number {\n\t\t// track all properties in a Solid effect\n\t\t// @ts-expect-error\n\t\tthis.#reactivityTriggerObject[$TRACK]\n\n\t\treturn super.size\n\t}\n\toverride set size(n: number) {\n\t\t// @ts-expect-error readonly property according to TS, but in JS it is\n\t\t// assignable though nothing happens. We need this so that the property\n\t\t// behaves the same after we override it.\n\t\tsuper.size = n\n\t}\n}\n","import '@lume/custom-attributes/dist/index.js' // polyfills global Custom Attributes API\nimport type {CustomAttribute} from '@lume/custom-attributes/dist/index.js'\nimport {CancelablePromise, PromiseCancellation} from './CancelablePromise.js'\nimport type {ElementWithBehaviors, PossibleBehaviorConstructor, PossibleBehaviorInstance} from './BehaviorRegistry.js'\nimport {BehaviorMap} from './BehaviorMap.js'\n\n// All elements have a `behaviors` property. If null, it the element has no\n// behaviors, otherwise the property is a map of behavior names to behavior\n// instances.\n// One instance of is instantiated per element with has=\"\" attribute.\nexport class HasAttribute implements CustomAttribute {\n\t// properties defined by CustomAttribute\n\tdeclare ownerElement: ElementWithBehaviors\n\tdeclare value: string\n\tdeclare name: string\n\n\tget behaviors() {\n\t\treturn this.ownerElement.behaviors\n\t}\n\n\tobservers = new Map<PossibleBehaviorInstance, MutationObserver>()\n\telementDefinedPromises = new Map<string, CancelablePromise<CustomElementConstructor>>()\n\n\tisConnected = false // TODO move to base class\n\n\t// TODO an improvement would be that behaviors are instantiated on element\n\t// construction, though that will add some complexity (probably patching of\n\t// many native APIs). Probably needs a change in custom-attributes first so it\n\t// handles attributes during element construction.\n\tconnectedCallback() {\n\t\tthis.isConnected = true\n\t\tthis.changedCallback('', this.value)\n\t}\n\n\tdisconnectedCallback() {\n\t\tthis.isConnected = false\n\t\tthis.#skipConnectedCheck = true\n\t\tthis.changedCallback(this.value, '')\n\t\tthis.#skipConnectedCheck = false\n\t}\n\n\t#skipConnectedCheck = false\n\n\tchangedCallback(oldVal: string, newVal: string) {\n\t\tif (!this.#skipConnectedCheck) {\n\t\t\tif (!this.isConnected) return\n\t\t}\n\n\t\tconst currentBehaviors = this.getBehaviorNames(newVal)\n\t\tconst previousBehaviors = this.getBehaviorNames(oldVal)\n\n\t\t// small optimization: if no previous or new behaviors, just quit\n\t\t// early. It would still function the same without this.\n\t\tif (currentBehaviors.length == 0 && previousBehaviors.length == 0) return\n\n\t\tconst {removed, added} = this.getDiff(previousBehaviors, currentBehaviors)\n\t\tthis.handleDiff(removed, added)\n\t}\n\n\tprivate getBehaviorNames(string: string) {\n\t\tif (string.trim() == '') return []\n\t\telse return string.split(/\\s+/)\n\t}\n\n\tprivate getDiff(previousBehaviors: string[], currentBehaviors: string[]) {\n\t\tconst diff = {\n\t\t\tremoved: [] as string[],\n\t\t\tadded: currentBehaviors,\n\t\t}\n\n\t\tfor (let i = 0, l = previousBehaviors.length; i < l; i += 1) {\n\t\t\tconst oldBehavior = previousBehaviors[i]\n\n\t\t\t// if it exists in the previousBehaviors but not the newBehaviors, then\n\t\t\t// the node was removed.\n\t\t\tif (!diff.added.includes(oldBehavior)) {\n\t\t\t\tdiff.removed.push(oldBehavior)\n\t\t\t}\n\n\t\t\t// otherwise the old value also exists in the set of new values, so\n\t\t\t// therefore it wasn't added or removed, so let's remove it so we\n\t\t\t// don't count it as added\n\t\t\telse {\n\t\t\t\tdiff.added.splice(diff.added.indexOf(oldBehavior), 1)\n\t\t\t}\n\t\t}\n\n\t\treturn diff\n\t}\n\n\tprivate handleDiff(removed: string[], added: string[]) {\n\t\tfor (const name of removed) this.disconnectBehavior(name)\n\t\tfor (const name of added) this.connectBehavior(name)\n\t}\n\n\tprivate async connectBehavior(name: string) {\n\t\tconst Behavior = elementBehaviors.get(name)\n\n\t\tif (!Behavior) return\n\n\t\t// TODO Read observedAttributes during the define() call instead, like\n\t\t// custom elements.\n\t\tconst observedAttributes = Behavior.observedAttributes\n\n\t\tconst tagName = this.ownerElement.tagName\n\n\t\ttry {\n\t\t\t// if the element is a custom element and the behavior specifies to wait for it to be defined\n\t\t\tif (Behavior.awaitElementDefined && tagName.includes('-') && !customElements.get(tagName.toLowerCase())) {\n\t\t\t\tconst promiseId = name + '_' + tagName\n\t\t\t\tlet promise = this.elementDefinedPromises.get(promiseId)\n\n\t\t\t\tif (!promise) {\n\t\t\t\t\tpromise = new CancelablePromise(customElements.whenDefined(tagName.toLowerCase()), {\n\t\t\t\t\t\trejectOnCancel: true,\n\t\t\t\t\t})\n\t\t\t\t\tthis.elementDefinedPromises.set(promiseId, promise)\n\t\t\t\t}\n\n\t\t\t\tawait promise\n\t\t\t\tthis.elementDefinedPromises.delete(promiseId)\n\t\t\t}\n\n\t\t\tif (this.isConnected) {\n\t\t\t\tconst behavior = new Behavior(this.ownerElement)\n\t\t\t\tthis.behaviors.set(name, behavior)\n\t\t\t\tbehavior.connectedCallback?.(this.ownerElement)\n\n\t\t\t\tif (Array.isArray(observedAttributes) && observedAttributes.length) {\n\t\t\t\t\tthis.fireInitialAttributeChangedCallbacks(behavior, observedAttributes)\n\t\t\t\t\tthis.createAttributeObserver(behavior)\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tif (!(e instanceof PromiseCancellation)) throw e\n\n\t\t\t// do nothing if promise canceled\n\t\t}\n\t}\n\n\tprivate disconnectBehavior(name: string) {\n\t\tconst promiseId = name + '_' + this.ownerElement.tagName\n\t\tconst promise = this.elementDefinedPromises.get(promiseId)\n\n\t\tif (promise) {\n\t\t\tpromise.cancel()\n\t\t\tthis.elementDefinedPromises.delete(promiseId)\n\t\t}\n\n\t\tconst behavior = this.behaviors.get(name)\n\n\t\t// There will only be a behavior if connectBehavior both created it and\n\t\t// ran its connectedCallback.\n\t\tif (!behavior) return\n\n\t\tbehavior.disconnectedCallback?.(this.ownerElement)\n\t\tthis.destroyAttributeObserver(behavior)\n\t\tthis.behaviors.delete(name)\n\t}\n\n\tdestroyAttributeObserver(behavior: PossibleBehaviorInstance) {\n\t\tconst observer = this.observers.get(behavior)\n\t\tif (!observer) return\n\t\tobserver.disconnect()\n\t\tthis.observers.delete(behavior)\n\t}\n\n\t// Behaviors observe attribute changes, implemented with MutationObserver\n\t//\n\t// We have to create one observer per behavior because otherwise\n\t// MutationObserver doesn't have an API for disconnecting from a single\n\t// element, only for disconnecting from all elements.\n\tcreateAttributeObserver(behavior: PossibleBehaviorInstance) {\n\t\tconst el = this.ownerElement\n\n\t\tconst observer = new MutationObserver(records => {\n\t\t\tif (!behavior.attributeChangedCallback) return\n\n\t\t\t// Because we get mutations in order, and we have all the attribute\n\t\t\t// values for a given attribute along the way while iterating on\n\t\t\t// mutation records, we keep track of previous and current attribute\n\t\t\t// values (per attribute name) with this variable and thus we can\n\t\t\t// fire behavior.attributeChangedCallback with each previous and\n\t\t\t// current value. For why we need to do this, see\n\t\t\t// https://stackoverflow.com/questions/60593551.\n\t\t\tlet lastAttributeValues: {[k: string]: string | null} = {}\n\n\t\t\tlet name = ''\n\n\t\t\tfor (const record of records) {\n\t\t\t\tif (record.type !== 'attributes') continue\n\n\t\t\t\tname = record.attributeName!\n\n\t\t\t\tif (lastAttributeValues[name] === undefined) {\n\t\t\t\t\tlastAttributeValues[name] = record.oldValue\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tbehavior.attributeChangedCallback(name, lastAttributeValues[name], record.oldValue, this.ownerElement)\n\n\t\t\t\tlastAttributeValues[name] = record.oldValue\n\t\t\t}\n\n\t\t\tlet attr: Attr | null\n\n\t\t\tfor (const name in lastAttributeValues) {\n\t\t\t\tattr = el.attributes.getNamedItem(name)\n\t\t\t\tbehavior.attributeChangedCallback(\n\t\t\t\t\tname,\n\t\t\t\t\tlastAttributeValues[name],\n\t\t\t\t\tattr === null ? null : attr.value,\n\t\t\t\t\tthis.ownerElement,\n\t\t\t\t)\n\t\t\t}\n\t\t})\n\n\t\tobserver.observe(el, {\n\t\t\tattributes: true,\n\t\t\tattributeOldValue: true,\n\t\t\tattributeFilter: (behavior.constructor as PossibleBehaviorConstructor).observedAttributes,\n\t\t})\n\n\t\tthis.observers.set(behavior, observer)\n\t}\n\n\tfireInitialAttributeChangedCallbacks(behavior: PossibleBehaviorInstance, attributes: string[]) {\n\t\tif (!behavior.attributeChangedCallback) return\n\n\t\tfor (const name of attributes) {\n\t\t\tif (this.ownerElement.hasAttribute(name))\n\t\t\t\tbehavior.attributeChangedCallback(\n\t\t\t\t\tname,\n\t\t\t\t\tnull,\n\t\t\t\t\tthis.ownerElement.attributes.getNamedItem(name)!.value,\n\t\t\t\t\tthis.ownerElement,\n\t\t\t\t)\n\t\t}\n\t}\n}\n\n// Avoid errors trying to use DOM APIs in non-DOM environments (f.e. server-side rendering).\nif (globalThis.window?.document) {\n\t// stores the behaviors associated to each element.\n\tconst behaviorMaps = new WeakMap()\n\n\tObject.defineProperty(Element.prototype, 'behaviors', {\n\t\tget() {\n\t\t\tlet thisBehaviors = null\n\n\t\t\tif (!behaviorMaps.has(this)) {\n\t\t\t\tbehaviorMaps.set(this, (thisBehaviors = new BehaviorMap()))\n\t\t\t} else thisBehaviors = behaviorMaps.get(this)\n\n\t\t\treturn thisBehaviors\n\t\t},\n\t})\n\n\tconst _attachShadow = Element.prototype.attachShadow\n\n\tElement.prototype.attachShadow = function (options) {\n\t\tconst root = _attachShadow.call(this, options)\n\n\t\troot.customAttributes.define('has', HasAttribute)\n\n\t\treturn root\n\t}\n\n\tglobalThis.customAttributes.define('has', HasAttribute)\n}\n","import type {Constructor} from 'lowclass'\nimport type {BehaviorMap} from './BehaviorMap.js'\n\nexport const whenDefinedPromises: Map<string, Promise<void>> = new Map()\n\nexport class BehaviorRegistry {\n\tprotected _definedBehaviors = new Map<string, PossibleBehaviorConstructor>()\n\n\tdefine<T extends PossibleBehaviorConstructor>(name: string, Behavior: T) {\n\t\tif (!this._definedBehaviors.has(name)) {\n\t\t\tthis._definedBehaviors.set(name, Behavior)\n\t\t} else {\n\t\t\tthrow new Error(`Behavior ${name} is already defined.`)\n\t\t}\n\t}\n\n\tget(name: string) {\n\t\treturn this._definedBehaviors.get(name)\n\t}\n\n\thas(name: string) {\n\t\treturn this._definedBehaviors.has(name)\n\t}\n\n\t// TODO WIP, similar to customElements.whenDefined, so that code can wait for\n\t// behaviors to be defined, which will help with load order issues when we\n\t// set autoDefineElements to true by default in LUME (causes elements to be\n\t// defined in module load order, which may not happen after all behaviors\n\t// are loaded).\n\twhenDefined(name: string) {\n\t\tlet resolve!: () => void\n\t\tconst p = new Promise<void>(r => (resolve = r))\n\n\t\tif (!this.has(name)) {\n\t\t\twhenDefinedPromises.set(name, p)\n\t\t} else {\n\t\t\tresolve()\n\t\t}\n\n\t\treturn p\n\t}\n}\n\nexport let elementBehaviors: BehaviorRegistry\n\n// Avoid errors trying to use DOM APIs in non-DOM environments (f.e. server-side rendering).\nif (globalThis.window?.document) {\n\telementBehaviors = globalThis.elementBehaviors = new BehaviorRegistry()\n}\n\ndeclare global {\n\t// const doesn't always work (TS bug). At time of writing this, it doesn't work in this TS playground example:\n\t// https://www.typescriptlang.org/play?#code/KYDwDg9gTgLgBAbzgXwFCoCbAMYBsCGUwcA5rhAEb66KpxzYQB2AzvAGYQQBccTArgFsKwKKjSoylagBUAFgEsWAOk4Q4Aeg1wAolCjQANHAXwYipgGsWcAAZrbJm0wjws7BU2AYgA\n\t// And discussions:\n\t// https://discord.com/channels/508357248330760243/508357248330760249/1019034094060978228\n\t// https://discord.com/channels/508357248330760243/1019017621397585961\n\tvar elementBehaviors: BehaviorRegistry\n\n\tinterface Window {\n\t\telementBehaviors: BehaviorRegistry\n\t}\n}\n\nexport type ElementBehaviors = {behaviors: BehaviorMap}\n\nexport type ElementWithBehaviors = Element & ElementBehaviors\n\nexport type PossibleBehaviorConstructor = Constructor<\n\tPossibleBehaviorInstance,\n\t[ElementWithBehaviors],\n\t{awaitElementDefined?: boolean; observedAttributes?: string[]}\n>\n\nexport type PossibleBehaviorInstance = {\n\tconnectedCallback?: (element: Element) => void\n\tdisconnectedCallback?: (element: Element) => void\n\tattributeChangedCallback?: (attr: string, oldValue: string | null, newValue: string | null, element: Element) => void\n\t[k: string]: any\n\t[k: number]: any\n}\n","// TODO: element behaviors currently don't work on elements when they are\n// defined (via elementBehaviors.define()) after the elements are already in the\n// DOM. Make it order-independent.\n\nexport * from './HasAttribute.js'\nexport * from './BehaviorMap.js'\nexport * from './BehaviorRegistry.js'\n\n// Leave this last line alone, it gets automatically updated when publishing a\n// new version of this package.\nexport const version = '3.0.4'\n"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","forEach","Array","CustomAttributeRegistry","constructor","ownerDocument","_attrMap","Map","_elementMap","WeakMap","_observer","MutationObserver","mutations","m","type","this","_getConstructor","attributeName","_handleChange","target","oldValue","removedNodes","_elementDisconnected","addedNodes","_elementConnected","element","nodeType","attributes","attr","name","_constructor","_upgradeAttr","map","inst","disconnectedCallback","delete","Error","define","attrName","Class","set","_reobserve","_observe","observe","childList","subtree","attributeOldValue","attributeFilter","keys","_unobserve","disconnect","node","matches","querySelectorAll","el","oldVal","newVal","getAttribute","ownerElement","connectedCallback","changedCallback","globalThis","window","document","_attachShadow","Element","attachShadow","options","root","customAttributes","_","storage","privates","Privates","PromiseCancellation","CancelablePromise","Promise","executor","rejectOnCancel","originalReject","promise","super","resolve","reject","then","canceled","catch","error","cancel","$PROXY","$TRACK","signalOptions","equals","a","b","ERROR","runEffects","runQueue","NOTPENDING","STALE","PENDING","UNOWNED","owned","cleanups","context","owner","transPending","setTransPending","createSignal","Owner","SuspenseContext","Transition","Scheduler","ExternalSourceFactory","Listener","Pending","Updates","Effects","ExecCount","assign","s","observers","observerSlots","pending","comparator","undefined","readSignal","bind","running","sources","has","tValue","writeSignal","createMemo","fn","c","createComputation","tState","push","updateComputation","result","q","runUpdates","i","length","data","untrack","listener","getListener","children","resolveChildren","runningTransition","state","updates","lookUpstream","sSlot","sourceSlots","isComp","TransitionRunning","add","disposed","pure","markDownstream","cleanNode","time","runComputation","queueMicrotask","nextValue","err","handleError","updatedAt","init","tOwned","track","trigger","ordinary","onCleanup","dispose","triggerInTransition","done","l","t","Set","effects","promises","queue","res","startTransition","inTransition","x","runTop","suspense","inFallback","ancestors","top","prev","wait","item","tasks","size","apply","scheduleQueue","e","d","v","len","completeUpdates","ignore","source","pop","index","obs","n","fns","lookup","f","isArray","results","createProvider","id","props","createComputed","defaultValue","createContext","$RAW","$NODE","$NAME","isWrappable","proto","getPrototypeOf","unwrap","unwrapped","isFrozen","slice","desc","getOwnPropertyDescriptors","getDataNodes","nodes","getDataNode","property","createDataNode","trackSelf","internal","$","setProperty","proxyTraps","receiver","tracked","getOwnPropertyDescriptor","isFunction","args","wrap","deleteProperty","ownKeys","Reflect","configurable","writable","p","Proxy","og","$ROOT","applyState","parent","merge","previous","j","start","end","newEnd","newIndicesNext","keyVal","Math","min","temp","newIndices","targetKeys","previousKeys","reconcile","BehaviorMap","find","predicate","behavior","clear","modifier","entries","iterator","callbackfn","thisArg","HasAttribute","elementDefinedPromises","isConnected","behaviors","currentBehaviors","getBehaviorNames","previousBehaviors","removed","added","getDiff","handleDiff","string","trim","split","diff","oldBehavior","includes","splice","indexOf","disconnectBehavior","connectBehavior","async","Behavior","elementBehaviors","observedAttributes","tagName","awaitElementDefined","customElements","toLowerCase","promiseId","whenDefined","fireInitialAttributeChangedCallbacks","createAttributeObserver","destroyAttributeObserver","observer","records","attributeChangedCallback","lastAttributeValues","record","getNamedItem","hasAttribute","behaviorMaps","thisBehaviors","whenDefinedPromises","BehaviorRegistry","_definedBehaviors","r"],"sourceRoot":""}